From: Aron Xu <aron@debian.org>
Date: Sat, 26 Jan 2013 08:55:30 -0500
Subject: Upstream post release changes

Revert "[script] ..why detect gtk twice"

This reverts commit 4138a52ea879cd13c5c453f1dcec672fe547e242.

use CMAKE_CURRENT_LIST_FILE instead of CMAKE_CURRENT_LIST_DIR in order to support old cmake versions

compatible with old qt and dbus

..cmake 2.6, die in peace.

add option to disable gui part

fix compatible with gcc 4.6

disable auto highlight for keyboard

fix reload addon config for im

when reloading input method config, also call all reloadconfig
on all im that belongs to it

port keyboard to use imeclass2 to reload config

use enter to commit should be false.. why its still there

port pinyin to imclass2

add a painful api..

typo.

use timeout to schedule layout update

fix global hotkey for khotkey, icewm

seems a some application use the first group for global hotkey, set the
default layout to the first one to solve this problem.

reset default layout upon change

revert remove_quick behavior, add "full" version

add the original word into tab sequence

fix autoeng cursor position

add the original word into tab sequence

set override default highlight (require 4.2.8)

check _XKB_RULES_NAMES attribute on root window.

revert to fix wrong rule names resolution when rule files are symlinks.

remove compiler warning on utarray_insert to 0.

no one actually including -gio.h.. ok..

resolve soname for dlopen, if available, fallback to native if opencc is failed

also update preedit when using tab.

commit preedit should clean up the preedit

don't draw upper part if there is nothing in preedit

check lua52...

require lua51

... wrong module names...

move to libexec

initial implementation of notification item

integration with classic ui and auto fallback is implemented.

testing on unity, adjust some icon

now function is complete, need test

fix label order

fix warning

respect property array settings

implement get group properties

now menu also work under unity

&> doesn't work on dash

implement LayoutUpdated

fix typo

delay the signal process, for workaround gtk app

add some icon :D

refine icon

be able to use RTLD_GLOBAL to load library for addon
---
 CMakeLists.txt                                     |   49 +-
 cmake/FcitxMacro.cmake                             |    3 +-
 cmake/FindLua.cmake                                |   15 +-
 data/addon.desc                                    |    5 +
 data/script/fcitx-configtool                       |    6 +-
 data/script/fcitx-diagnose.sh                      |   14 +
 src/frontend/gtk2/client.c                         |    5 +-
 src/frontend/gtk2/fcitximcontext-gio.h             |   52 --
 src/frontend/gtk2/fcitximcontext.h                 |    8 +-
 src/frontend/ipc/CMakeLists.txt                    |    1 +
 src/frontend/ipc/ipc.c                             |  561 ++++++---------
 src/frontend/qt/qfcitxinputcontext.cpp             |    9 +-
 src/im/keyboard/fcitx-keyboard.desc                |    2 +-
 src/im/keyboard/keyboard.c                         |  163 +++--
 src/im/keyboard/keyboard.h                         |    3 +-
 src/im/pinyin/py.c                                 |   20 +-
 src/lib/fcitx-qt/fcitxqtconnection.cpp             |    3 +-
 src/lib/fcitx-utils/utarray.h                      |   17 +
 src/lib/fcitx/addon.c                              |    1 +
 src/lib/fcitx/addon.h                              |    7 +-
 src/lib/fcitx/candidate-internal.h                 |   45 ++
 src/lib/fcitx/candidate.c                          |   28 +-
 src/lib/fcitx/candidate.h                          |   11 +
 src/lib/fcitx/frontend.c                           |    2 +-
 src/lib/fcitx/ime.c                                |   20 +-
 src/lib/fcitx/ime.h                                |    2 +-
 src/lib/fcitx/module.c                             |    2 +-
 src/lib/fcitx/module.h                             |    6 +-
 src/lib/fcitx/ui.c                                 |   14 +-
 src/lib/fcitx/ui.h                                 |    2 +-
 src/module/CMakeLists.txt                          |    1 +
 src/module/autoeng/AutoEng.c                       |  128 ++--
 src/module/chttrans/chttrans-opencc.c              |    4 +
 src/module/chttrans/chttrans.c                     |    7 +-
 src/module/chttrans/chttrans_p.h                   |    1 +
 src/module/clipboard/clipboard.c                   |    3 +
 src/module/dbusstuff/property.c                    |  150 ++++
 src/module/dbusstuff/property.h                    |   47 ++
 src/module/lua/CMakeLists.txt                      |    2 +-
 src/module/notificationitem/CMakeLists.txt         |   18 +
 src/module/notificationitem/dbusmenu.c             |  720 ++++++++++++++++++++
 .../fcitx-notificationitem.conf.in                 |   11 +
 .../fcitx-notificationitem.fxaddon                 |   25 +
 src/module/notificationitem/notificationitem.c     |  623 +++++++++++++++++
 src/module/notificationitem/notificationitem.h     |   28 +
 src/module/notificationitem/notificationitem_p.h   |   41 ++
 src/module/quickphrase/quickphrase.c               |    5 +-
 src/module/xkb/xkb.c                               |  126 ++--
 src/ui/classic/TrayWindow.c                        |    2 +-
 src/ui/classic/TrayWindow.h                        |    1 +
 src/ui/classic/classicui.c                         |   61 +-
 src/ui/classic/classicui.h                         |    1 +
 src/ui/classic/skin.c                              |   16 +-
 src/ui/kimpanel/kimpanel.c                         |  157 ++---
 tools/gui/quickphrase-editor/CMakeLists.txt        |    2 +-
 tools/gui/quickphrase-editor/editordialog.ui       |   16 +-
 tools/gui/wrapper/CMakeLists.txt                   |    4 +-
 57 files changed, 2545 insertions(+), 731 deletions(-)
 delete mode 100644 src/frontend/gtk2/fcitximcontext-gio.h
 create mode 100644 src/lib/fcitx/candidate-internal.h
 create mode 100644 src/module/dbusstuff/property.c
 create mode 100644 src/module/dbusstuff/property.h
 create mode 100644 src/module/notificationitem/CMakeLists.txt
 create mode 100644 src/module/notificationitem/dbusmenu.c
 create mode 100644 src/module/notificationitem/fcitx-notificationitem.conf.in
 create mode 100644 src/module/notificationitem/fcitx-notificationitem.fxaddon
 create mode 100644 src/module/notificationitem/notificationitem.c
 create mode 100644 src/module/notificationitem/notificationitem.h
 create mode 100644 src/module/notificationitem/notificationitem_p.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index f24678e..60fd844 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,4 +1,4 @@
-cmake_minimum_required(VERSION 2.6)
+cmake_minimum_required(VERSION 2.8)
 
 project(fcitx)
 
@@ -17,8 +17,9 @@ option(ENABLE_DEBUG "Enable Debug" OFF)
 option(ENABLE_TABLE "Enable Table IM" ON)
 option(ENABLE_GTK2_IM_MODULE "Enable GTK2 IM Module" ON)
 option(ENABLE_GTK3_IM_MODULE "Enable GTK3 IM Module" OFF)
-option(ENABLE_QT "Enable Qt-based lib and configuration GUI" On)
+option(ENABLE_QT "Enable Qt-based lib" On)
 option(ENABLE_QT_IM_MODULE "Enable Qt IM Module" ON)
+option(ENABLE_QT_GUI "Enable Qt-based configuration GUI" On)
 option(ENABLE_OPENCC "Enable OpenCC for Chinese Transform" ON)
 option(FORCE_OPENCC
   "Enable opencc even if the library is not found at compile time" Off)
@@ -213,18 +214,50 @@ set(FCITX4_ADDON_CONFIG_INSTALL_DIR ${addonconfigdir})
 set(FCITX4_INPUTMETHOD_CONFIG_INSTALL_DIR ${imconfigdir})
 set(FCITX4_PACKAGE_NAME ${package})
 
+function(_RESOLVE_LIBRARY_PATH _FILE_NAME _LIBRARY_PATH)
+    if (CMAKE_OBJDUMP)
+        execute_process (
+            COMMAND ${CMAKE_OBJDUMP} -p "${_LIBRARY_PATH}"
+            RESULT_VARIABLE STATUS
+            OUTPUT_VARIABLE OBJDUMP_RESULT
+            ERROR_QUIET
+        )
+        string(REGEX REPLACE ".*SONAME +([^ ]+)\n.*$" "\\1" SONAME_OUT "${OBJDUMP_RESULT}")
+        if (SONAME_OUT)
+            set(_FILE_NAME_OUT "${SONAME_OUT}")
+        endif ()
+    endif()
+    if (NOT _FILE_NAME_OUT)
+        get_filename_component(_FILE_NAME_OUT "${_LIBRARY_PATH}" NAME)
+    endif()
+    set(${_FILE_NAME} ${_FILE_NAME_OUT} PARENT_SCOPE)
+endfunction()
+
+
 if (NOT DEFINED OPENCC_LIBRARY_FILENAME)
-  set(OPENCC_LIBRARY_FILENAME
-    "${CMAKE_SHARED_LIBRARY_PREFIX}opencc${CMAKE_SHARED_LIBRARY_SUFFIX}")
+    if (OPENCC_LIBRARIES)
+        _RESOLVE_LIBRARY_PATH(OPENCC_LIBRARY_FILENAME "${OPENCC_LIBRARIES}")
+    else ()
+        set(OPENCC_LIBRARY_FILENAME
+            "${CMAKE_SHARED_LIBRARY_PREFIX}opencc${CMAKE_SHARED_LIBRARY_SUFFIX}")
+    endif ()
 endif()
 
 if(NOT DEFINED ENCHANT_LIBRARY_FILENAME)
-  set(ENCHANT_LIBRARY_FILENAME
-    "${CMAKE_SHARED_LIBRARY_PREFIX}enchant${CMAKE_SHARED_LIBRARY_SUFFIX}")
+    if (ENCHANT_LIBRARIES)
+        _RESOLVE_LIBRARY_PATH(ENCHANT_LIBRARY_FILENAME "${ENCHANT_LIBRARIES}")
+    else ()
+        set(ENCHANT_LIBRARY_FILENAME
+            "${CMAKE_SHARED_LIBRARY_PREFIX}enchant${CMAKE_SHARED_LIBRARY_SUFFIX}")
+    endif ()
 endif()
 if(NOT DEFINED PRESAGE_LIBRARY_FILENAME)
-  set(PRESAGE_LIBRARY_FILENAME
-    "${CMAKE_SHARED_LIBRARY_PREFIX}presage${CMAKE_SHARED_LIBRARY_SUFFIX}")
+    if (PRESAGE_LIBRARIES)
+        _RESOLVE_LIBRARY_PATH(PRESAGE_LIBRARY_FILENAME "${PRESAGE_LIBRARIES}")
+    else ()
+        set(PRESAGE_LIBRARY_FILENAME
+            "${CMAKE_SHARED_LIBRARY_PREFIX}presage${CMAKE_SHARED_LIBRARY_SUFFIX}")
+    endif ()
 endif()
 
 set(CMAKE_C_FLAGS "-Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -fvisibility=hidden ${CMAKE_C_FLAGS}")
diff --git a/cmake/FcitxMacro.cmake b/cmake/FcitxMacro.cmake
index da5d5d5..7c1ba38 100644
--- a/cmake/FcitxMacro.cmake
+++ b/cmake/FcitxMacro.cmake
@@ -122,7 +122,8 @@ function(fcitx_parse_arguments prefix _optionNames
 endfunction()
 
 
-set(FCITX_MACRO_CMAKE_DIR "${CMAKE_CURRENT_LIST_DIR}")
+get_filename_component(FCITX_MACRO_CMAKE_DIR
+  "${CMAKE_CURRENT_LIST_FILE}" PATH)
 set(FCITX_CMAKE_HELPER_SCRIPT "${FCITX_MACRO_CMAKE_DIR}/fcitx-cmake-helper.sh"
   CACHE INTERNAL "fcitx-cmake-helper" FORCE)
 mark_as_advanced(FORCE FCITX_CMAKE_HELPER_SCRIPT)
diff --git a/cmake/FindLua.cmake b/cmake/FindLua.cmake
index 6cd4db1..3887b74 100644
--- a/cmake/FindLua.cmake
+++ b/cmake/FindLua.cmake
@@ -36,9 +36,20 @@ find_package(PkgConfig)
 unset(LUA_LIBRARIES CACHE)
 unset(__pkg_config_checked_LUA CACHE)
 if("${LUA_MODULE_NAME}" STREQUAL "")
-  set(LUA_MODULE_NAME lua)
+  pkg_check_modules(LUA lua5.2)
+  # try best to find lua52
+  if(NOT LUA_FOUND)
+    unset(__pkg_config_checked_LUA CACHE)
+    pkg_check_modules(LUA lua)
+  endif()
+  # Too lazy to increase indentation...
+  if(NOT LUA_FOUND)
+    unset(__pkg_config_checked_LUA CACHE)
+    pkg_check_modules(LUA lua5.1)
+  endif()
+else()
+  pkg_check_modules(LUA "${LUA_MODULE_NAME}")
 endif()
-pkg_check_modules(LUA "${LUA_MODULE_NAME}")
 
 include(FindPackageHandleStandardArgs)
 # handle the QUIETLY and REQUIRED arguments and set LUA_FOUND to TRUE if
diff --git a/data/addon.desc b/data/addon.desc
index 8afd45d..7326434 100644
--- a/data/addon.desc
+++ b/data/addon.desc
@@ -71,6 +71,11 @@ Type=String
 DefaultValue=
 Description=Fallback UI Addon
 
+[Addon/LoadLocal]
+Type=Boolean
+DefaultValue=False
+Description=Use RTLD_GLOBAL to load library
+
 [Addon/Advance]
 Type=Boolean
 DefaultValue=False
diff --git a/data/script/fcitx-configtool b/data/script/fcitx-configtool
index 7ad1046..1c2ba41 100755
--- a/data/script/fcitx-configtool
+++ b/data/script/fcitx-configtool
@@ -69,7 +69,7 @@ detectDE() {
 }
 
 run_kde() {
-    if (kcmshell4 --list 2>/dev/null | grep ^kcm_fcitx &>/dev/null); then
+    if (kcmshell4 --list 2>/dev/null | grep ^kcm_fcitx > /dev/null 2>&1); then
         if [ x"$1" != x ]; then
             exec kcmshell4 kcm_fcitx --args "$1"
         else
@@ -79,13 +79,13 @@ run_kde() {
 }
 
 run_gtk() {
-    if which fcitx-config-gtk &>/dev/null; then
+    if which fcitx-config-gtk > /dev/null 2>&1; then
         exec fcitx-config-gtk "$1"
     fi
 }
 
 run_gtk3() {
-    if which fcitx-config-gtk3 &>/dev/null; then
+    if which fcitx-config-gtk3 > /dev/null 2>&1; then
         exec fcitx-config-gtk3 "$1"
     fi
 }
diff --git a/data/script/fcitx-diagnose.sh b/data/script/fcitx-diagnose.sh
index cc3f205..c901174 100755
--- a/data/script/fcitx-diagnose.sh
+++ b/data/script/fcitx-diagnose.sh
@@ -413,11 +413,20 @@ check_env() {
     write_order_list "DISPLAY:"
     write_quote_str "DISPLAY='${DISPLAY}'"
     write_order_list "$(_ "Keyboard Layout:")"
+    increase_cur_level 1
+    write_order_list "$(code_inline setxkbmap)"
     if type setxkbmap &> /dev/null; then
         write_quote_cmd setxkbmap -print
     else
         write_paragraph "$(print_not_found 'setxkbmap')"
     fi
+    write_order_list "$(code_inline xprop)"
+    if type xprop &> /dev/null; then
+        write_quote_cmd xprop -root _XKB_RULES_NAMES
+    else
+        write_paragraph "$(print_not_found 'xprop')"
+    fi
+    increase_cur_level -1
     write_order_list "$(_ "Locale:")"
     if type locale &> /dev/null; then
         increase_cur_level 1
@@ -686,6 +695,11 @@ check_gtk() {
     check_gtk_immodule 2
     check_gtk_immodule 3
     increase_cur_level -1
+    write_order_list "$(_ 'Gtk IM module cache:')"
+    increase_cur_level 1
+    check_gtk_immodule_cache 2
+    check_gtk_immodule_cache 3
+    increase_cur_level -1
 }
 
 
diff --git a/src/frontend/gtk2/client.c b/src/frontend/gtk2/client.c
index 8329071..52c5c9a 100644
--- a/src/frontend/gtk2/client.c
+++ b/src/frontend/gtk2/client.c
@@ -31,7 +31,6 @@
 #include "client.h"
 #include "marshall.h"
 
-#define LOG_LEVEL DEBUG
 #define IC_NAME_MAX 64
 
 #define PREEDIT_TYPE_STRING_INT \
@@ -129,7 +128,7 @@ FcitxIMClient* FcitxIMClientOpen(FcitxIMClientConnectCallback connectcb, FcitxIM
 
 static void _changed_cb(DBusGProxy* proxy, char* service, char* old_owner, char* new_owner, gpointer user_data)
 {
-    FcitxLog(LOG_LEVEL, "_changed_cb");
+    FcitxLog(DEBUG, "_changed_cb");
     FcitxIMClient* client = (FcitxIMClient*) user_data;
     if (g_str_equal(service, client->servicename)) {
         gboolean new_owner_good = new_owner && (new_owner[0] != '\0');
@@ -151,7 +150,7 @@ static void _changed_cb(DBusGProxy* proxy, char* service, char* old_owner, char*
 
 static void _destroy_cb(DBusGProxy *proxy, gpointer user_data)
 {
-    FcitxLog(LOG_LEVEL, "_destroy_cb");
+    FcitxLog(DEBUG, "_destroy_cb");
     FcitxIMClient* client = (FcitxIMClient*) user_data;
     if (client->proxy == proxy) {
         g_object_unref(client->proxy);
diff --git a/src/frontend/gtk2/fcitximcontext-gio.h b/src/frontend/gtk2/fcitximcontext-gio.h
deleted file mode 100644
index 2805859..0000000
--- a/src/frontend/gtk2/fcitximcontext-gio.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2010~2012 by CSSlayer                                   *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
- ***************************************************************************/
-
-#ifndef __FCITX_IM_CONTEXT_H_
-#define __FCITX_IM_CONTEXT_H_
-
-#include <gtk/gtk.h>
-
-/*
-* Type macros.
-*/
-#define FCITX_TYPE_IM_CONTEXT \
-    (fcitx_im_context_get_type ())
-#define FCITX_IM_CONTEXT(obj) \
-    (G_TYPE_CHECK_INSTANCE_CAST ((obj), FCITX_TYPE_IM_CONTEXT, FcitxIMContext))
-#define FCITX_IM_CONTEXT_CLASS(klass) \
-    (G_TYPE_CHECK_CLASS_CAST ((klass), FCITX_TYPE_IM_CONTEXT, FcitxIMContextClass))
-#define FCITX_IS_IM_CONTEXT(obj) \
-    (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FCITX_TYPE_IM_CONTEXT))
-#define FCITX_IS_IM_CONTEXT_CLASS(klass) \
-    (G_TYPE_CHECK_CLASS_TYPE ((klass), FCITX_TYPE_IM_CONTEXT))
-#define FCITX_IM_CONTEXT_GET_CLASS(obj) \
-    (G_TYPE_CHECK_GET_CLASS ((obj), FCITX_TYPE_IM_CONTEXT, FcitxIMContextClass))
-
-G_BEGIN_DECLS
-
-typedef struct _FcitxIMContext FcitxIMContext;
-typedef struct _FcitxIMContextClass FcitxIMContextClass;
-
-GType fcitx_im_context_get_type(void);
-FcitxIMContext *fcitx_im_context_new(void);
-void fcitx_im_context_register_type(GTypeModule *type_module);
-
-G_END_DECLS
-#endif
-// kate: indent-mode cstyle; space-indent on; indent-width 0;
diff --git a/src/frontend/gtk2/fcitximcontext.h b/src/frontend/gtk2/fcitximcontext.h
index df52b3d..2805859 100644
--- a/src/frontend/gtk2/fcitximcontext.h
+++ b/src/frontend/gtk2/fcitximcontext.h
@@ -39,14 +39,14 @@
     (G_TYPE_CHECK_GET_CLASS ((obj), FCITX_TYPE_IM_CONTEXT, FcitxIMContextClass))
 
 G_BEGIN_DECLS
+
 typedef struct _FcitxIMContext FcitxIMContext;
 typedef struct _FcitxIMContextClass FcitxIMContextClass;
 
 GType fcitx_im_context_get_type(void);
-FcitxIMContext
-*fcitx_im_context_new(void);
-void fcitx_im_context_register_type
-(GTypeModule *type_module);
+FcitxIMContext *fcitx_im_context_new(void);
+void fcitx_im_context_register_type(GTypeModule *type_module);
+
 G_END_DECLS
 #endif
 // kate: indent-mode cstyle; space-indent on; indent-width 0;
diff --git a/src/frontend/ipc/CMakeLists.txt b/src/frontend/ipc/CMakeLists.txt
index c0ad389..b7bdecb 100644
--- a/src/frontend/ipc/CMakeLists.txt
+++ b/src/frontend/ipc/CMakeLists.txt
@@ -10,6 +10,7 @@ endif()
 
 set(FCITX_IPC_SOURCES
   ipc.c
+  ../../module/dbusstuff/property.c
   )
 
 fcitx_add_addon_full(ipc ${ipc_noinstall}
diff --git a/src/frontend/ipc/ipc.c b/src/frontend/ipc/ipc.c
index a29b1de..0b32b8f 100644
--- a/src/frontend/ipc/ipc.c
+++ b/src/frontend/ipc/ipc.c
@@ -24,6 +24,7 @@
 #include "fcitx/frontend.h"
 #include "fcitx-utils/utils.h"
 #include "module/dbus/fcitx-dbus.h"
+#include "module/dbusstuff/property.h"
 #include "fcitx/instance.h"
 #include "fcitx/module.h"
 #include "fcitx-utils/log.h"
@@ -33,6 +34,10 @@
 
 #define GetIPCIC(ic) ((FcitxIPCIC*) (ic)->privateic)
 
+#ifndef DBUS_ERROR_UNKNOWN_PROPERTY
+#define DBUS_ERROR_UNKNOWN_PROPERTY           "org.freedesktop.DBus.Error.UnknownProperty"
+#endif
+
 typedef struct _FcitxIPCCreateICPriv {
     DBusMessage* message;
     DBusConnection* conn;
@@ -60,14 +65,6 @@ typedef struct _FcitxIPCFrontend {
     FcitxInstance* owner;
 } FcitxIPCFrontend;
 
-typedef struct _FcitxDBusPropertyTable {
-    char* interface;
-    char* name;
-    char* type;
-    void (*getfunc)(void* arg, DBusMessageIter* iter);
-    void (*setfunc)(void* arg, DBusMessageIter* iter);
-} FcitxDBusPropertyTable;
-
 typedef struct _FcitxIPCKeyEvent {
     FcitxKeySym sym;
     unsigned int state;
@@ -101,208 +98,204 @@ static void IPCSetPropertyIMList(void* arg, DBusMessageIter* iter);
 static void IPCUpdateIMList(void* arg);
 static pid_t IPCGetPid(void* arg, FcitxInputContext* ic);
 
-static DBusMessage* FcitxDBusPropertyGet(FcitxIPCFrontend* ipc, DBusMessage* message);
-static DBusMessage* FcitxDBusPropertySet(FcitxIPCFrontend* ipc, DBusMessage* message);
-static DBusMessage* FcitxDBusPropertyGetAll(FcitxIPCFrontend* ipc, DBusMessage* message);
-
 const FcitxDBusPropertyTable propertTable[] = {
     { FCITX_IM_DBUS_INTERFACE, "IMList", "a(sssb)", IPCGetPropertyIMList, IPCSetPropertyIMList },
     { NULL, NULL, NULL, NULL, NULL }
 };
 
 const char * im_introspection_xml =
-    "<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\"\n"
-    "\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"
-    "<node>\n"
-    "  <interface name=\"" DBUS_INTERFACE_INTROSPECTABLE "\">\n"
-    "    <method name=\"Introspect\">\n"
-    "      <arg name=\"data\" direction=\"out\" type=\"s\"/>\n"
-    "    </method>\n"
-    "  </interface>\n"
-    "  <interface name=\"" DBUS_INTERFACE_PROPERTIES "\">\n"
-    "    <method name=\"Get\">\n"
-    "      <arg name=\"interface_name\" direction=\"in\" type=\"s\"/>\n"
-    "      <arg name=\"property_name\" direction=\"in\" type=\"s\"/>\n"
-    "      <arg name=\"value\" direction=\"out\" type=\"v\"/>\n"
-    "    </method>\n"
-    "    <method name=\"Set\">\n"
-    "      <arg name=\"interface_name\" direction=\"in\" type=\"s\"/>\n"
-    "      <arg name=\"property_name\" direction=\"in\" type=\"s\"/>\n"
-    "      <arg name=\"value\" direction=\"in\" type=\"v\"/>\n"
-    "    </method>\n"
-    "    <method name=\"GetAll\">\n"
-    "      <arg name=\"interface_name\" direction=\"in\" type=\"s\"/>\n"
-    "      <arg name=\"values\" direction=\"out\" type=\"a{sv}\"/>\n"
-    "    </method>\n"
-    "    <signal name=\"PropertiesChanged\">\n"
-    "      <arg name=\"interface_name\" type=\"s\"/>\n"
-    "      <arg name=\"changed_properties\" type=\"a{sv}\"/>\n"
-    "      <arg name=\"invalidated_properties\" type=\"as\"/>\n"
-    "    </signal>\n"
-    "  </interface>\n"
-    "  <interface name=\"" FCITX_IM_DBUS_INTERFACE "\">\n"
-    "    <method name=\"CreateIC\">\n"
-    "      <arg name=\"icid\" direction=\"out\" type=\"i\"/>\n"
-    "      <arg name=\"keyval1\" direction=\"out\" type=\"u\"/>\n"
-    "      <arg name=\"state1\" direction=\"out\" type=\"u\"/>\n"
-    "      <arg name=\"keyval2\" direction=\"out\" type=\"u\"/>\n"
-    "      <arg name=\"state2\" direction=\"out\" type=\"u\"/>\n"
-    "    </method>\n"
-    "    <method name=\"CreateICv2\">\n"
-    "      <arg name=\"appname\" direction=\"in\" type=\"s\"/>\n"
-    "      <arg name=\"icid\" direction=\"out\" type=\"i\"/>\n"
-    "      <arg name=\"enable\" direction=\"out\" type=\"b\"/>\n"
-    "      <arg name=\"keyval1\" direction=\"out\" type=\"u\"/>\n"
-    "      <arg name=\"state1\" direction=\"out\" type=\"u\"/>\n"
-    "      <arg name=\"keyval2\" direction=\"out\" type=\"u\"/>\n"
-    "      <arg name=\"state2\" direction=\"out\" type=\"u\"/>\n"
-    "    </method>\n"
-    "    <method name=\"CreateICv3\">\n"
-    "      <arg name=\"appname\" direction=\"in\" type=\"s\"/>\n"
-    "      <arg name=\"pid\" direction=\"in\" type=\"i\"/>\n"
-    "      <arg name=\"icid\" direction=\"out\" type=\"i\"/>\n"
-    "      <arg name=\"enable\" direction=\"out\" type=\"b\"/>\n"
-    "      <arg name=\"keyval1\" direction=\"out\" type=\"u\"/>\n"
-    "      <arg name=\"state1\" direction=\"out\" type=\"u\"/>\n"
-    "      <arg name=\"keyval2\" direction=\"out\" type=\"u\"/>\n"
-    "      <arg name=\"state2\" direction=\"out\" type=\"u\"/>\n"
-    "    </method>\n"
-    "    <method name=\"Exit\">\n"
-    "    </method>\n"
-    "    <method name=\"GetCurrentIM\">\n"
-    "      <arg name=\"im\" direction=\"out\" type=\"s\"/>\n"
-    "    </method>\n"
-    "    <method name=\"SetCurrentIM\">\n"
-    "      <arg name=\"im\" direction=\"in\" type=\"s\"/>\n"
-    "    </method>\n"
-    "    <method name=\"ReloadConfig\">\n"
-    "    </method>\n"
-    "    <method name=\"ReloadAddonConfig\">\n"
-    "      <arg name=\"addon\" direction=\"in\" type=\"s\"/>\n"
-    "    </method>\n"
-    "    <method name=\"Restart\">\n"
-    "    </method>\n"
-    "    <method name=\"Configure\">\n"
-    "    </method>\n"
-    "    <method name=\"ConfigureAddon\">\n"
-    "      <arg name=\"addon\" direction=\"in\" type=\"s\"/>\n"
-    "    </method>\n"
-    "    <method name=\"ConfigureIM\">\n"
-    "      <arg name=\"im\" direction=\"in\" type=\"s\"/>\n"
-    "    </method>\n"
-    "    <method name=\"GetCurrentUI\">\n"
-    "      <arg name=\"addon\" direction=\"out\" type=\"s\"/>\n"
-    "    </method>\n"
-    "    <method name=\"GetIMAddon\">\n"
-    "      <arg name=\"im\" direction=\"in\" type=\"s\"/>\n"
-    "      <arg name=\"addon\" direction=\"out\" type=\"s\"/>\n"
-    "    </method>\n"
-    "    <method name=\"ActivateIM\">\n"
-    "    </method>\n"
-    "    <method name=\"InactivateIM\">\n"
-    "    </method>\n"
-    "    <method name=\"ToggleIM\">\n"
-    "    </method>\n"
-    "    <method name=\"GetCurrentState\">\n"
-    "      <arg name=\"state\" direction=\"out\" type=\"i\"/>\n"
-    "    </method>\n"
-    "    <property access=\"readwrite\" type=\"a(sssb)\" name=\"IMList\">\n"
-    "      <annotation name=\"org.freedesktop.DBus.Property.EmitsChangedSignal\" value=\"true\"/>"
-    "    </property>\n"
-    "  </interface>\n"
-    "</node>\n";
+    "<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" "
+    "\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">"
+    "<node>"
+    "<interface name=\"" DBUS_INTERFACE_INTROSPECTABLE "\">"
+    "<method name=\"Introspect\">"
+    "<arg name=\"data\" direction=\"out\" type=\"s\"/>"
+    "</method>"
+    "</interface>"
+    "<interface name=\"" DBUS_INTERFACE_PROPERTIES "\">"
+    "<method name=\"Get\">"
+    "<arg name=\"interface_name\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"property_name\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"value\" direction=\"out\" type=\"v\"/>"
+    "</method>"
+    "<method name=\"Set\">"
+    "<arg name=\"interface_name\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"property_name\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"value\" direction=\"in\" type=\"v\"/>"
+    "</method>"
+    "<method name=\"GetAll\">"
+    "<arg name=\"interface_name\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"values\" direction=\"out\" type=\"a{sv}\"/>"
+    "</method>"
+    "<signal name=\"PropertiesChanged\">"
+    "<arg name=\"interface_name\" type=\"s\"/>"
+    "<arg name=\"changed_properties\" type=\"a{sv}\"/>"
+    "<arg name=\"invalidated_properties\" type=\"as\"/>"
+    "</signal>"
+    "</interface>"
+    "<interface name=\"" FCITX_IM_DBUS_INTERFACE "\">"
+    "<method name=\"CreateIC\">"
+    "<arg name=\"icid\" direction=\"out\" type=\"i\"/>"
+    "<arg name=\"keyval1\" direction=\"out\" type=\"u\"/>"
+    "<arg name=\"state1\" direction=\"out\" type=\"u\"/>"
+    "<arg name=\"keyval2\" direction=\"out\" type=\"u\"/>"
+    "<arg name=\"state2\" direction=\"out\" type=\"u\"/>"
+    "</method>"
+    "<method name=\"CreateICv2\">"
+    "<arg name=\"appname\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"icid\" direction=\"out\" type=\"i\"/>"
+    "<arg name=\"enable\" direction=\"out\" type=\"b\"/>"
+    "<arg name=\"keyval1\" direction=\"out\" type=\"u\"/>"
+    "<arg name=\"state1\" direction=\"out\" type=\"u\"/>"
+    "<arg name=\"keyval2\" direction=\"out\" type=\"u\"/>"
+    "<arg name=\"state2\" direction=\"out\" type=\"u\"/>"
+    "</method>"
+    "<method name=\"CreateICv3\">"
+    "<arg name=\"appname\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"pid\" direction=\"in\" type=\"i\"/>"
+    "<arg name=\"icid\" direction=\"out\" type=\"i\"/>"
+    "<arg name=\"enable\" direction=\"out\" type=\"b\"/>"
+    "<arg name=\"keyval1\" direction=\"out\" type=\"u\"/>"
+    "<arg name=\"state1\" direction=\"out\" type=\"u\"/>"
+    "<arg name=\"keyval2\" direction=\"out\" type=\"u\"/>"
+    "<arg name=\"state2\" direction=\"out\" type=\"u\"/>"
+    "</method>"
+    "<method name=\"Exit\">"
+    "</method>"
+    "<method name=\"GetCurrentIM\">"
+    "<arg name=\"im\" direction=\"out\" type=\"s\"/>"
+    "</method>"
+    "<method name=\"SetCurrentIM\">"
+    "<arg name=\"im\" direction=\"in\" type=\"s\"/>"
+    "</method>"
+    "<method name=\"ReloadConfig\">"
+    "</method>"
+    "<method name=\"ReloadAddonConfig\">"
+    "<arg name=\"addon\" direction=\"in\" type=\"s\"/>"
+    "</method>"
+    "<method name=\"Restart\">"
+    "</method>"
+    "<method name=\"Configure\">"
+    "</method>"
+    "<method name=\"ConfigureAddon\">"
+    "<arg name=\"addon\" direction=\"in\" type=\"s\"/>"
+    "</method>"
+    "<method name=\"ConfigureIM\">"
+    "<arg name=\"im\" direction=\"in\" type=\"s\"/>"
+    "</method>"
+    "<method name=\"GetCurrentUI\">"
+    "<arg name=\"addon\" direction=\"out\" type=\"s\"/>"
+    "</method>"
+    "<method name=\"GetIMAddon\">"
+    "<arg name=\"im\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"addon\" direction=\"out\" type=\"s\"/>"
+    "</method>"
+    "<method name=\"ActivateIM\">"
+    "</method>"
+    "<method name=\"InactivateIM\">"
+    "</method>"
+    "<method name=\"ToggleIM\">"
+    "</method>"
+    "<method name=\"GetCurrentState\">"
+    "<arg name=\"state\" direction=\"out\" type=\"i\"/>"
+    "</method>"
+    "<property access=\"readwrite\" type=\"a(sssb)\" name=\"IMList\">"
+    "<annotation name=\"org.freedesktop.DBus.Property.EmitsChangedSignal\" value=\"true\"/>"
+    "</property>"
+    "</interface>"
+    "</node>";
 
 const char * ic_introspection_xml =
-    "<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\"\n"
-    "\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"
-    "<node>\n"
-    "  <interface name=\"org.freedesktop.DBus.Introspectable\">\n"
-    "    <method name=\"Introspect\">\n"
-    "      <arg name=\"data\" direction=\"out\" type=\"s\"/>\n"
-    "    </method>\n"
-    "  </interface>\n"
-    "  <interface name=\"" FCITX_IC_DBUS_INTERFACE "\">\n"
-    "    <method name=\"EnableIC\">\n"
-    "    </method>\n"
-    "    <method name=\"CloseIC\">\n"
-    "    </method>\n"
-    "    <method name=\"FocusIn\">\n"
-    "    </method>\n"
-    "    <method name=\"FocusOut\">\n"
-    "    </method>\n"
-    "    <method name=\"Reset\">\n"
-    "    </method>\n"
-    "    <method name=\"CommitPreedit\">\n"
-    "    </method>\n"
-    "    <method name=\"MouseEvent\">\n"
-    "      <arg name=\"x\" direction=\"in\" type=\"i\"/>\n"
-    "    </method>\n"
-    "    <method name=\"SetCursorLocation\">\n"
-    "      <arg name=\"x\" direction=\"in\" type=\"i\"/>\n"
-    "      <arg name=\"y\" direction=\"in\" type=\"i\"/>\n"
-    "    </method>\n"
-    "    <method name=\"SetCursorRect\">\n"
-    "      <arg name=\"x\" direction=\"in\" type=\"i\"/>\n"
-    "      <arg name=\"y\" direction=\"in\" type=\"i\"/>\n"
-    "      <arg name=\"w\" direction=\"in\" type=\"i\"/>\n"
-    "      <arg name=\"h\" direction=\"in\" type=\"i\"/>\n"
-    "    </method>\n"
-    "    <method name=\"SetCapacity\">\n"
-    "      <arg name=\"caps\" direction=\"in\" type=\"u\"/>\n"
-    "    </method>\n"
-    "    <method name=\"SetSurroundingText\">\n"
-    "      <arg name=\"text\" direction=\"in\" type=\"s\"/>\n"
-    "      <arg name=\"cursor\" direction=\"in\" type=\"u\"/>\n"
-    "      <arg name=\"anchor\" direction=\"in\" type=\"u\"/>\n"
-    "    </method>\n"
-    "    <method name=\"SetSurroundingTextPosition\">\n"
-    "      <arg name=\"cursor\" direction=\"in\" type=\"u\"/>\n"
-    "      <arg name=\"anchor\" direction=\"in\" type=\"u\"/>\n"
-    "    </method>\n"
-    "    <method name=\"DestroyIC\">\n"
-    "    </method>\n"
-    "    <method name=\"ProcessKeyEvent\">\n"
-    "      <arg name=\"keyval\" direction=\"in\" type=\"u\"/>\n"
-    "      <arg name=\"keycode\" direction=\"in\" type=\"u\"/>\n"
-    "      <arg name=\"state\" direction=\"in\" type=\"u\"/>\n"
-    "      <arg name=\"type\" direction=\"in\" type=\"i\"/>\n"
-    "      <arg name=\"time\" direction=\"in\" type=\"u\"/>\n"
-    "      <arg name=\"ret\" direction=\"out\" type=\"i\"/>\n"
-    "    </method>\n"
-    "    <signal name=\"EnableIM\">\n"
-    "    </signal>\n"
-    "    <signal name=\"CloseIM\">\n"
-    "    </signal>\n"
-    "    <signal name=\"CommitString\">\n"
-    "      <arg name=\"str\" type=\"s\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"UpdatePreedit\">\n"
-    "      <arg name=\"str\" type=\"s\"/>\n"
-    "      <arg name=\"cursorpos\" type=\"i\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"DeleteSurroundingText\">\n"
-    "      <arg name=\"offset\" type=\"i\"/>\n"
-    "      <arg name=\"nchar\" type=\"u\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"UpdateFormattedPreedit\">\n"
-    "      <arg name=\"str\" type=\"a(si)\"/>\n"
-    "      <arg name=\"cursorpos\" type=\"i\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"UpdateClientSideUI\">\n"
-    "      <arg name=\"auxup\" type=\"s\"/>\n"
-    "      <arg name=\"auxdown\" type=\"s\"/>\n"
-    "      <arg name=\"preedit\" type=\"s\"/>\n"
-    "      <arg name=\"candidateword\" type=\"s\"/>\n"
-    "      <arg name=\"imname\" type=\"s\"/>\n"
-    "      <arg name=\"cursorpos\" type=\"i\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"ForwardKey\">\n"
-    "      <arg name=\"keyval\" type=\"u\"/>\n"
-    "      <arg name=\"state\" type=\"u\"/>\n"
-    "      <arg name=\"type\" type=\"i\"/>\n"
-    "    </signal>\n"
-    "  </interface>\n"
-    "</node>\n";
+    "<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" "
+    "\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">"
+    "<node>"
+    "<interface name=\"org.freedesktop.DBus.Introspectable\">"
+    "<method name=\"Introspect\">"
+    "<arg name=\"data\" direction=\"out\" type=\"s\"/>"
+    "</method>"
+    "</interface>"
+    "<interface name=\"" FCITX_IC_DBUS_INTERFACE "\">"
+    "<method name=\"EnableIC\">"
+    "</method>"
+    "<method name=\"CloseIC\">"
+    "</method>"
+    "<method name=\"FocusIn\">"
+    "</method>"
+    "<method name=\"FocusOut\">"
+    "</method>"
+    "<method name=\"Reset\">"
+    "</method>"
+    "<method name=\"CommitPreedit\">"
+    "</method>"
+    "<method name=\"MouseEvent\">"
+    "<arg name=\"x\" direction=\"in\" type=\"i\"/>"
+    "</method>"
+    "<method name=\"SetCursorLocation\">"
+    "<arg name=\"x\" direction=\"in\" type=\"i\"/>"
+    "<arg name=\"y\" direction=\"in\" type=\"i\"/>"
+    "</method>"
+    "<method name=\"SetCursorRect\">"
+    "<arg name=\"x\" direction=\"in\" type=\"i\"/>"
+    "<arg name=\"y\" direction=\"in\" type=\"i\"/>"
+    "<arg name=\"w\" direction=\"in\" type=\"i\"/>"
+    "<arg name=\"h\" direction=\"in\" type=\"i\"/>"
+    "</method>"
+    "<method name=\"SetCapacity\">"
+    "<arg name=\"caps\" direction=\"in\" type=\"u\"/>"
+    "</method>"
+    "<method name=\"SetSurroundingText\">"
+    "<arg name=\"text\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"cursor\" direction=\"in\" type=\"u\"/>"
+    "<arg name=\"anchor\" direction=\"in\" type=\"u\"/>"
+    "</method>"
+    "<method name=\"SetSurroundingTextPosition\">"
+    "<arg name=\"cursor\" direction=\"in\" type=\"u\"/>"
+    "<arg name=\"anchor\" direction=\"in\" type=\"u\"/>"
+    "</method>"
+    "<method name=\"DestroyIC\">"
+    "</method>"
+    "<method name=\"ProcessKeyEvent\">"
+    "<arg name=\"keyval\" direction=\"in\" type=\"u\"/>"
+    "<arg name=\"keycode\" direction=\"in\" type=\"u\"/>"
+    "<arg name=\"state\" direction=\"in\" type=\"u\"/>"
+    "<arg name=\"type\" direction=\"in\" type=\"i\"/>"
+    "<arg name=\"time\" direction=\"in\" type=\"u\"/>"
+    "<arg name=\"ret\" direction=\"out\" type=\"i\"/>"
+    "</method>"
+    "<signal name=\"EnableIM\">"
+    "</signal>"
+    "<signal name=\"CloseIM\">"
+    "</signal>"
+    "<signal name=\"CommitString\">"
+    "<arg name=\"str\" type=\"s\"/>"
+    "</signal>"
+    "<signal name=\"UpdatePreedit\">"
+    "<arg name=\"str\" type=\"s\"/>"
+    "<arg name=\"cursorpos\" type=\"i\"/>"
+    "</signal>"
+    "<signal name=\"DeleteSurroundingText\">"
+    "<arg name=\"offset\" type=\"i\"/>"
+    "<arg name=\"nchar\" type=\"u\"/>"
+    "</signal>"
+    "<signal name=\"UpdateFormattedPreedit\">"
+    "<arg name=\"str\" type=\"a(si)\"/>"
+    "<arg name=\"cursorpos\" type=\"i\"/>"
+    "</signal>"
+    "<signal name=\"UpdateClientSideUI\">"
+    "<arg name=\"auxup\" type=\"s\"/>"
+    "<arg name=\"auxdown\" type=\"s\"/>"
+    "<arg name=\"preedit\" type=\"s\"/>"
+    "<arg name=\"candidateword\" type=\"s\"/>"
+    "<arg name=\"imname\" type=\"s\"/>"
+    "<arg name=\"cursorpos\" type=\"i\"/>"
+    "</signal>"
+    "<signal name=\"ForwardKey\">"
+    "<arg name=\"keyval\" type=\"u\"/>"
+    "<arg name=\"state\" type=\"u\"/>"
+    "<arg name=\"type\" type=\"i\"/>"
+    "</signal>"
+    "</interface>"
+    "</node>";
 
 FCITX_DEFINE_PLUGIN(fcitx_ipc, frontend, FcitxFrontend) = {
     IPCCreate,
@@ -588,15 +581,6 @@ void IPCGetWindowRect(void* arg, FcitxInputContext* ic, int* x, int* y, int* w,
     *h = GetIPCIC(ic)->height;
 }
 
-static inline DBusMessage* IPCDBusUnknownMethod(DBusMessage *msg)
-{
-    DBusMessage* reply = dbus_message_new_error_printf(msg,
-                                                       DBUS_ERROR_UNKNOWN_METHOD,
-                                                       "No such method with signature (%s)",
-                                                       dbus_message_get_signature(msg));
-    return reply;
-}
-
 static DBusHandlerResult IPCDBusEventHandler(DBusConnection *connection, DBusMessage *msg, void *user_data)
 {
     FcitxIPCFrontend* ipc = (FcitxIPCFrontend*) user_data;
@@ -610,11 +594,11 @@ static DBusHandlerResult IPCDBusEventHandler(DBusConnection *connection, DBusMes
 
         dbus_message_append_args(reply, DBUS_TYPE_STRING, &im_introspection_xml, DBUS_TYPE_INVALID);
     } else if (dbus_message_is_method_call(msg, DBUS_INTERFACE_PROPERTIES, "Get")) {
-        reply = FcitxDBusPropertyGet(ipc, msg);
+        reply = FcitxDBusPropertyGet(ipc, propertTable, msg);
     } else if (dbus_message_is_method_call(msg, DBUS_INTERFACE_PROPERTIES, "Set")) {
-        reply = FcitxDBusPropertySet(ipc, msg);
+        reply = FcitxDBusPropertySet(ipc, propertTable, msg);
     } else if (dbus_message_is_method_call(msg, DBUS_INTERFACE_PROPERTIES, "GetAll")) {
-        reply = FcitxDBusPropertyGetAll(ipc, msg);
+        reply = FcitxDBusPropertyGetAll(ipc, propertTable, msg);
     } else if (dbus_message_is_method_call(msg, FCITX_IM_DBUS_INTERFACE, "CreateIC")
             || dbus_message_is_method_call(msg, FCITX_IM_DBUS_INTERFACE, "CreateICv2")
             || dbus_message_is_method_call(msg, FCITX_IM_DBUS_INTERFACE, "CreateICv3")
@@ -649,7 +633,7 @@ static DBusHandlerResult IPCDBusEventHandler(DBusConnection *connection, DBusMes
             FcitxInstanceSwitchIMByName(instance, imname);
             reply = dbus_message_new_method_return(msg);
         } else {
-            reply = IPCDBusUnknownMethod(msg);
+            reply = FcitxDBusPropertyUnknownMethod(msg);
         }
         dbus_error_free(&error);
     } else if (dbus_message_is_method_call(msg, FCITX_IM_DBUS_INTERFACE, "GetIMAddon")) {
@@ -664,7 +648,7 @@ static DBusHandlerResult IPCDBusEventHandler(DBusConnection *connection, DBusMes
             reply = dbus_message_new_method_return(msg);
             dbus_message_append_args(reply, DBUS_TYPE_STRING, &name, DBUS_TYPE_INVALID);
         } else {
-            reply = IPCDBusUnknownMethod(msg);
+            reply = FcitxDBusPropertyUnknownMethod(msg);
         }
         dbus_error_free(&error);
     } else if (dbus_message_is_method_call(msg, FCITX_IM_DBUS_INTERFACE, "GetCurrentUI")) {
@@ -703,7 +687,7 @@ static DBusHandlerResult IPCDBusEventHandler(DBusConnection *connection, DBusMes
             }
             reply = dbus_message_new_method_return(msg);
         } else {
-            reply = IPCDBusUnknownMethod(msg);
+            reply = FcitxDBusPropertyUnknownMethod(msg);
         }
         dbus_error_free(&error);
     } else if (dbus_message_is_method_call(msg, FCITX_IM_DBUS_INTERFACE, "ConfigureIM")) {
@@ -716,7 +700,7 @@ static DBusHandlerResult IPCDBusEventHandler(DBusConnection *connection, DBusMes
             }
             reply = dbus_message_new_method_return(msg);
         } else {
-            reply = IPCDBusUnknownMethod(msg);
+            reply = FcitxDBusPropertyUnknownMethod(msg);
         }
         dbus_error_free(&error);
     } else if (dbus_message_is_method_call(msg, FCITX_IM_DBUS_INTERFACE, "ReloadAddonConfig")) {
@@ -729,7 +713,7 @@ static DBusHandlerResult IPCDBusEventHandler(DBusConnection *connection, DBusMes
             }
             reply = dbus_message_new_method_return(msg);
         } else {
-            reply = IPCDBusUnknownMethod(msg);
+            reply = FcitxDBusPropertyUnknownMethod(msg);
         }
         dbus_error_free(&error);
     } else if (dbus_message_is_method_call(msg, FCITX_IM_DBUS_INTERFACE, "ReloadConfig")) {
@@ -797,7 +781,7 @@ static DBusHandlerResult IPCICDBusEventHandler(DBusConnection *connection, DBusM
                 IPCICSetCursorRect(ipc, ic, x, y, 0, 0);
                 reply = dbus_message_new_method_return(msg);
             } else {
-                reply = IPCDBusUnknownMethod(msg);
+                reply = FcitxDBusPropertyUnknownMethod(msg);
             }
         } else if (dbus_message_is_method_call(msg, FCITX_IC_DBUS_INTERFACE, "SetCursorRect")) {
             int x, y, w, h;
@@ -808,7 +792,7 @@ static DBusHandlerResult IPCICDBusEventHandler(DBusConnection *connection, DBusM
                 IPCICSetCursorRect(ipc, ic, x, y, w, h);
                 reply = dbus_message_new_method_return(msg);
             } else {
-                reply = IPCDBusUnknownMethod(msg);
+                reply = FcitxDBusPropertyUnknownMethod(msg);
             }
         } else if (dbus_message_is_method_call(msg, FCITX_IC_DBUS_INTERFACE, "SetCapacity")) {
             uint32_t flags;
@@ -821,7 +805,7 @@ static DBusHandlerResult IPCICDBusEventHandler(DBusConnection *connection, DBusM
                 }
                 reply = dbus_message_new_method_return(msg);
             } else {
-                reply = IPCDBusUnknownMethod(msg);
+                reply = FcitxDBusPropertyUnknownMethod(msg);
             }
             result = DBUS_HANDLER_RESULT_HANDLED;
         } else if (dbus_message_is_method_call(msg, FCITX_IC_DBUS_INTERFACE, "SetSurroundingText")) {
@@ -839,7 +823,7 @@ static DBusHandlerResult IPCICDBusEventHandler(DBusConnection *connection, DBusM
                 }
                 reply = dbus_message_new_method_return(msg);
             } else {
-                reply = IPCDBusUnknownMethod(msg);
+                reply = FcitxDBusPropertyUnknownMethod(msg);
             }
             result = DBUS_HANDLER_RESULT_HANDLED;
         } else if (dbus_message_is_method_call(msg, FCITX_IC_DBUS_INTERFACE, "SetSurroundingTextPosition")) {
@@ -854,7 +838,7 @@ static DBusHandlerResult IPCICDBusEventHandler(DBusConnection *connection, DBusM
                 }
                 reply = dbus_message_new_method_return(msg);
             } else {
-                reply = IPCDBusUnknownMethod(msg);
+                reply = FcitxDBusPropertyUnknownMethod(msg);
             }
             result = DBUS_HANDLER_RESULT_HANDLED;
         } else if (dbus_message_is_method_call(msg, FCITX_IC_DBUS_INTERFACE, "DestroyIC")) {
@@ -880,7 +864,7 @@ static DBusHandlerResult IPCICDBusEventHandler(DBusConnection *connection, DBusM
                 dbus_message_append_args(reply, DBUS_TYPE_INT32, &ret, DBUS_TYPE_INVALID);
                 flush = true;
             } else {
-                reply = IPCDBusUnknownMethod(msg);
+                reply = FcitxDBusPropertyUnknownMethod(msg);
             }
         }
         dbus_error_free(&error);
@@ -1211,133 +1195,6 @@ boolean IPCCheckICFromSameApplication(void* arg, FcitxInputContext* icToCheck, F
     return strcmp(ipcicToCheck->appname, ipcic->appname) == 0;
 }
 
-DBusMessage* FcitxDBusPropertyGet(FcitxIPCFrontend* ipc, DBusMessage* message)
-{
-    DBusError error;
-    dbus_error_init(&error);
-    char *interface;
-    char *property;
-    DBusMessage* reply = NULL;
-    if (dbus_message_get_args(message, &error,
-                              DBUS_TYPE_STRING, &interface,
-                              DBUS_TYPE_STRING, &property,
-                              DBUS_TYPE_INVALID)) {
-        int index = 0;
-        while (propertTable[index].interface != NULL) {
-            if (strcmp(propertTable[index].interface, interface) == 0
-                    && strcmp(propertTable[index].name, property) == 0)
-                break;
-            index ++;
-        }
-
-        if (propertTable[index].interface) {
-            DBusMessageIter args, variant;
-            reply = dbus_message_new_method_return(message);
-            dbus_message_iter_init_append(reply, &args);
-            dbus_message_iter_open_container(&args, DBUS_TYPE_VARIANT, propertTable[index].type, &variant);
-            if (propertTable[index].getfunc)
-                propertTable[index].getfunc(ipc, &variant);
-            dbus_message_iter_close_container(&args, &variant);
-        }
-        else {
-            reply = dbus_message_new_error_printf(message, DBUS_ERROR_UNKNOWN_PROPERTY, "No such property ('%s.%s')", interface, property);
-        }
-    }
-    else {
-        reply = IPCDBusUnknownMethod(message);
-    }
-
-    return reply;
-}
-
-DBusMessage* FcitxDBusPropertySet(FcitxIPCFrontend* ipc, DBusMessage* message)
-{
-    DBusError error;
-    dbus_error_init(&error);
-    char *interface;
-    char *property;
-    DBusMessage* reply = NULL;
-
-    DBusMessageIter args, variant;
-    dbus_message_iter_init(message, &args);
-
-    if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_STRING)
-        goto dbus_property_set_end;
-
-    dbus_message_iter_get_basic(&args, &interface);
-    dbus_message_iter_next(&args);
-
-    if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_STRING)
-        goto dbus_property_set_end;
-    dbus_message_iter_get_basic(&args, &property);
-    dbus_message_iter_next(&args);
-
-    if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_VARIANT)
-        goto dbus_property_set_end;
-
-    dbus_message_iter_recurse(&args, &variant);
-    int index = 0;
-    while (propertTable[index].interface != NULL) {
-        if (strcmp(propertTable[index].interface, interface) == 0
-                && strcmp(propertTable[index].name, property) == 0)
-            break;
-        index ++;
-    }
-    if (propertTable[index].setfunc) {
-        propertTable[index].setfunc(ipc, &variant);
-        reply = dbus_message_new_method_return(message);
-    }
-    else {
-        reply = dbus_message_new_error_printf(message, DBUS_ERROR_UNKNOWN_PROPERTY, "No such property ('%s.%s')", interface, property);
-    }
-
-dbus_property_set_end:
-    if (!reply)
-        reply = IPCDBusUnknownMethod(message);
-
-    return reply;
-}
-
-DBusMessage* FcitxDBusPropertyGetAll(FcitxIPCFrontend* ipc, DBusMessage* message)
-{
-    DBusError error;
-    dbus_error_init(&error);
-    char *interface;
-    DBusMessage* reply = NULL;
-    if (dbus_message_get_args(message, &error,
-                              DBUS_TYPE_STRING, &interface,
-                              DBUS_TYPE_INVALID)) {
-        reply = dbus_message_new_method_return(message);
-        int index = 0;
-        DBusMessageIter args;
-        dbus_message_iter_init_append(reply, &args);
-        DBusMessageIter array, entry;
-        dbus_message_iter_open_container(&args, DBUS_TYPE_ARRAY, "{sv}", &array);
-
-        while (propertTable[index].interface != NULL) {
-            if (strcmp(propertTable[index].interface, interface) == 0 && propertTable[index].getfunc) {
-                dbus_message_iter_open_container(&array, DBUS_TYPE_DICT_ENTRY,
-                                                 NULL, &entry);
-
-                dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &propertTable[index].name);
-                DBusMessageIter variant;
-                dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT, propertTable[index].type, &variant);
-                propertTable[index].getfunc(ipc, &variant);
-                dbus_message_iter_close_container(&entry, &variant);
-
-                dbus_message_iter_close_container(&array, &entry);
-            }
-            index ++;
-        }
-        dbus_message_iter_close_container(&args, &array);
-    }
-    if (!reply)
-        reply = IPCDBusUnknownMethod(message);
-
-    return reply;
-}
-
-
 void IPCGetPropertyIMList(void* arg, DBusMessageIter* args)
 {
     FcitxIPCFrontend* ipc = (FcitxIPCFrontend*) arg;
diff --git a/src/frontend/qt/qfcitxinputcontext.cpp b/src/frontend/qt/qfcitxinputcontext.cpp
index d6b4d1a..c37bdf8 100644
--- a/src/frontend/qt/qfcitxinputcontext.cpp
+++ b/src/frontend/qt/qfcitxinputcontext.cpp
@@ -187,11 +187,14 @@ QString QFcitxInputContext::language()
 
 void QFcitxInputContext::commitPreedit()
 {
-    if (m_commitPreedit.length() > 0) {
+    if (m_preeditList.length() > 0) {
         QInputMethodEvent e;
-        e.setCommitString(m_commitPreedit);
-        m_commitPreedit.clear();
+        if (m_commitPreedit.length() > 0) {
+            e.setCommitString(m_commitPreedit);
+            m_commitPreedit.clear();
+        }
         sendEvent(e);
+        m_preeditList.clear();
     }
 }
 
diff --git a/src/im/keyboard/fcitx-keyboard.desc b/src/im/keyboard/fcitx-keyboard.desc
index e7a9e72..0016833 100644
--- a/src/im/keyboard/fcitx-keyboard.desc
+++ b/src/im/keyboard/fcitx-keyboard.desc
@@ -35,7 +35,7 @@ Advance=True
 
 [Keyboard/UseEnterToCommit]
 Type=Boolean
-DefaultValue=True
+DefaultValue=False
 Description=Use enter to commit the existing string
 
 [Keyboard/HotkeyAddToUserDict]
diff --git a/src/im/keyboard/keyboard.c b/src/im/keyboard/keyboard.c
index b3ee1eb..6445d0b 100644
--- a/src/im/keyboard/keyboard.c
+++ b/src/im/keyboard/keyboard.c
@@ -140,8 +140,14 @@ void Ucs4ToUtf8(iconv_t conv, uint32_t ucs4, char* utf8)
 
 CONFIG_DESC_DEFINE(GetKeyboardConfigDesc, "fcitx-keyboard.desc")
 
-FCITX_DEFINE_PLUGIN(fcitx_keyboard, ime, FcitxIMClass) = {
+FCITX_DEFINE_PLUGIN(fcitx_keyboard, ime2, FcitxIMClass2) = {
     FcitxKeyboardCreate,
+    NULL,
+    FcitxKeyboardReloadConfig,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
     NULL
 };
 
@@ -154,7 +160,7 @@ static const char* FcitxKeyboardGetPastStream(void* arg)
     char* surrounding = NULL;
     unsigned int cursor = 0, anchor = 0;
     if (FcitxInstanceGetSurroundingText(keyboard->owner, FcitxInstanceGetCurrentIC(keyboard->owner), &surrounding, &cursor, &anchor)) {
-        int len = cursor + strlen(keyboard->buffer) + 1;
+        int len = cursor + strlen(keyboard->buffer[0]) + 1;
         if (keyboard->lastLength < len) {
             free(keyboard->tempBuffer);
             while (keyboard->lastLength < len)
@@ -179,7 +185,7 @@ static const char* FcitxKeyboardGetPastStream(void* arg)
     }
     else
 #endif
-    return keyboard->buffer;
+    return keyboard->buffer[0];
 }
 
 static const char* FcitxKeyboardGetFutureStream(void* arg)
@@ -261,7 +267,7 @@ void FcitxKeyboardLayoutCreate(FcitxKeyboard* keyboard,
     iface.DoInput = FcitxKeyboardDoInput;
     iface.GetCandWords = FcitxKeyboardGetCandWords;
     iface.Save = FcitxKeyboardSave;
-    iface.ReloadConfig = FcitxKeyboardReloadConfig;
+    iface.ReloadConfig = NULL;
     iface.OnClose = FcitxKeyboardOnClose;
 
     FcitxInstanceRegisterIMv2(
@@ -493,6 +499,8 @@ boolean FcitxKeyboardInit(void *arg)
                             CONTEXT_DISABLE_QUICKPHRASE, &flag);
     FcitxInstanceSetContext(layout->owner->owner,
                             CONTEXT_DISABLE_FULLWIDTH, &flag);
+    FcitxInstanceSetContext(layout->owner->owner,
+                            CONTEXT_DISABLE_AUTO_FIRST_CANDIDATE_HIGHTLIGHT, &flag);
     if (layout->variantString) {
         char *string;
         fcitx_utils_alloc_cat_str(string, layout->layoutString, ",",
@@ -510,9 +518,10 @@ boolean FcitxKeyboardInit(void *arg)
 
 void FcitxKeyboardCommitBuffer(FcitxKeyboard* keyboard)
 {
-    if (keyboard->buffer[0]) {
-        FcitxInstanceCommitString(keyboard->owner, FcitxInstanceGetCurrentIC(keyboard->owner),
-                                    keyboard->buffer);
+    if (keyboard->buffer[0][0]) {
+        FcitxInstanceCommitString(keyboard->owner,
+                                  FcitxInstanceGetCurrentIC(keyboard->owner),
+                                  keyboard->buffer[0]);
         FcitxKeyboardResetIM(keyboard);
     }
 }
@@ -521,7 +530,8 @@ void  FcitxKeyboardResetIM(void *arg)
 {
     FcitxKeyboardLayout *layout = (FcitxKeyboardLayout*) arg;
     FcitxKeyboard *keyboard = layout->owner;
-    keyboard->buffer[0] = '\0';
+    keyboard->cursor_moved = false;
+    keyboard->buffer[0][0] = '\0';
     keyboard->cursorPos = 0;
     keyboard->composeBuffer[0] = 0;
     keyboard->n_compose = 0;
@@ -556,9 +566,10 @@ FcitxKeyboardSetBuff(FcitxKeyboard *keyboard, const char *str)
     int len = strlen(str);
     if (len > FCITX_KEYBOARD_MAX_BUFFER)
         len = FCITX_KEYBOARD_MAX_BUFFER;
-    memcpy(keyboard->buffer, str, len);
+    memcpy(keyboard->buffer[0], str, len);
     keyboard->cursorPos = len;
-    keyboard->buffer[len] = '\0';
+    keyboard->buffer[0][len] = '\0';
+    keyboard->cursor_moved = false;
 }
 
 static INPUT_RETURN_VALUE
@@ -573,49 +584,60 @@ FcitxKeyboardHandleFocus(FcitxKeyboard *keyboard, FcitxKeySym sym,
         return IRV_TO_PROCESS;
     FcitxGlobalConfig *fc = FcitxInstanceGetGlobalConfig(instance);
     if (FcitxHotkeyIsHotKey(sym, state, fc->nextWord)) {
-        cand_word = FcitxCandidateWordGetFocus(cand_list, true);
-        cand_word = FcitxCandidateWordGetNext(cand_list, cand_word);
-        if (!cand_word) {
-            FcitxCandidateWordSetPage(cand_list, 0);
-            cand_word = FcitxCandidateWordGetFirst(cand_list);
+        if (!keyboard->cursor_moved) {
+            cand_word = FcitxCandidateWordGetCurrentWindow(cand_list);
         } else {
-            FcitxCandidateWordSetFocus(
-                cand_list, FcitxCandidateWordGetIndex(cand_list, cand_word));
+            cand_word = FcitxCandidateWordGetFocus(cand_list, true);
+            cand_word = FcitxCandidateWordGetNext(cand_list, cand_word);
+            if (!cand_word) {
+                FcitxCandidateWordSetPage(cand_list, 0);
+            } else {
+                FcitxCandidateWordSetFocus(
+                    cand_list, FcitxCandidateWordGetIndex(cand_list,
+                                                          cand_word));
+            }
         }
     } else if (FcitxHotkeyIsHotKey(sym, state, fc->prevWord)) {
-        cand_word = FcitxCandidateWordGetFocus(cand_list, true);
-        cand_word = FcitxCandidateWordGetPrev(cand_list, cand_word);
-        if (!cand_word) {
-            FcitxCandidateWordSetPage(
-                cand_list, FcitxCandidateWordPageCount(cand_list) - 1);
-            cand_word = FcitxCandidateWordGetLast(cand_list);
+        if (!keyboard->cursor_moved) {
+            cand_word = FcitxCandidateWordGetByIndex(
+                cand_list,
+                FcitxCandidateWordGetCurrentWindowSize(cand_list) - 1);
         } else {
-            FcitxCandidateWordSetFocus(
-                cand_list, FcitxCandidateWordGetIndex(cand_list, cand_word));
-        }
-    } else if (FcitxHotkeyIsHotKey(sym, state,
-                                   FcitxConfigPrevPageKey(instance, fc))) {
-        cand_word = FcitxCandidateWordGetFocus(cand_list, true);
-        if (FcitxCandidateWordGoPrevPage(cand_list)) {
-            cand_word = FcitxCandidateWordGetCurrentWindow(cand_list) +
-                FcitxCandidateWordGetCurrentWindowSize(cand_list) - 1;
-        }
-    } else if (FcitxHotkeyIsHotKey(sym, state,
-                                   FcitxConfigNextPageKey(instance, fc))) {
-        cand_word = FcitxCandidateWordGetFocus(cand_list, true);
-        if (FcitxCandidateWordGoNextPage(cand_list)) {
-            cand_word = FcitxCandidateWordGetCurrentWindow(cand_list);
+            cand_word = FcitxCandidateWordGetFocus(cand_list, true);
+            cand_word = FcitxCandidateWordGetPrev(cand_list, cand_word);
+            if (cand_word) {
+                FcitxCandidateWordSetFocus(
+                    cand_list, FcitxCandidateWordGetIndex(cand_list,
+                                                          cand_word));
+            }
         }
     } else {
         return IRV_TO_PROCESS;
     }
-    FcitxCandidateWordSetType(cand_word, MSG_CANDIATE_CURSOR);
-    FcitxKeyboardSetBuff(keyboard, cand_word->strWord);
+    if (cand_word) {
+        FcitxCandidateWordSetType(cand_word, MSG_CANDIATE_CURSOR);
+        if (!keyboard->cursor_moved)
+            memcpy(keyboard->buffer[1], keyboard->buffer[0],
+                   sizeof(keyboard->buffer[0]));
+        FcitxKeyboardSetBuff(keyboard, cand_word->strWord);
+        keyboard->cursor_moved = true;
+    } else if (keyboard->cursor_moved) {
+        FcitxKeyboardSetBuff(keyboard, keyboard->buffer[1]);
+    } else {
+        return IRV_FLAG_UPDATE_INPUT_WINDOW;
+    }
+    FcitxInputStateSetShowCursor(input, true);
+    FcitxInstanceCleanInputWindowUp(instance);
     FcitxMessages *client_preedit = FcitxInputStateGetClientPreedit(input);
-    FcitxMessagesSetMessageCount(client_preedit, 0);
     FcitxMessagesAddMessageStringsAtLast(client_preedit, MSG_INPUT,
-                                         keyboard->buffer);
+                                         keyboard->buffer[0]);
     FcitxInputStateSetClientCursorPos(input, keyboard->cursorPos);
+
+    if (!FcitxInstanceICSupportPreedit(instance, FcitxInstanceGetCurrentIC(instance))) {
+        FcitxMessagesAddMessageStringsAtLast(FcitxInputStateGetPreedit(input),
+                                             MSG_INPUT, keyboard->buffer[0]);
+        FcitxInputStateSetCursorPos(input, keyboard->cursorPos);
+    }
     return IRV_FLAG_UPDATE_INPUT_WINDOW;
 }
 
@@ -659,7 +681,7 @@ INPUT_RETURN_VALUE FcitxKeyboardDoInput(void *arg, FcitxKeySym sym, unsigned int
 
         if (FcitxHotkeyIsHotKey(sym, state,
                                 keyboard->config.hkAddToUserDict)) {
-            if (FcitxSpellAddPersonal(instance, keyboard->buffer,
+            if (FcitxSpellAddPersonal(instance, keyboard->buffer[0],
                                       keyboard->dictLang)) {
                 return IRV_DO_NOTHING;
             }
@@ -669,7 +691,7 @@ INPUT_RETURN_VALUE FcitxKeyboardDoInput(void *arg, FcitxKeySym sym, unsigned int
             IsValidSym(sym, state)) {
             if (IsValidChar(result) || FcitxHotkeyIsHotKeyLAZ(sym, state) ||
                 FcitxHotkeyIsHotKeyUAZ(sym, state) || IsValidSym(sym, state) ||
-                (*keyboard->buffer &&
+                (*keyboard->buffer[0] &&
                  FcitxHotkeyIsHotKey(sym, state, FCITX_HYPHEN_APOS))) {
                 char buf[UTF8_MAX_LENGTH + 1];
                 memset(buf, 0, sizeof(buf));
@@ -679,35 +701,36 @@ INPUT_RETURN_VALUE FcitxKeyboardDoInput(void *arg, FcitxKeySym sym, unsigned int
                     Ucs4ToUtf8(keyboard->iconv, FcitxKeySymToUnicode(sym), buf);
                 size_t charlen = strlen(buf);
 
-                size_t len = strlen(keyboard->buffer);
+                size_t len = strlen(keyboard->buffer[0]);
                 if (len >= FCITX_KEYBOARD_MAX_BUFFER) {
                     FcitxInstanceCommitString(instance, currentIC,
-                                              keyboard->buffer);
+                                              keyboard->buffer[0]);
                     keyboard->cursorPos = 0;
-                    keyboard->buffer[0] = '\0';
+                    keyboard->buffer[0][0] = '\0';
                     len = 0;
                 }
-                if (keyboard->buffer[keyboard->cursorPos] != 0) {
-                    memmove(keyboard->buffer + keyboard->cursorPos + charlen,
-                            keyboard->buffer + keyboard->cursorPos,
+                if (keyboard->buffer[0][keyboard->cursorPos] != 0) {
+                    memmove(keyboard->buffer[0] + keyboard->cursorPos + charlen,
+                            keyboard->buffer[0] + keyboard->cursorPos,
                             len - keyboard->cursorPos);
                 }
-                keyboard->buffer[len + charlen] = 0;
-                strncpy(&keyboard->buffer[keyboard->cursorPos], buf, charlen);
+                keyboard->buffer[0][len + charlen] = '\0';
+                strncpy(&keyboard->buffer[0][keyboard->cursorPos],
+                        buf, charlen);
                 keyboard->cursorPos += charlen;
 
                 return IRV_DISPLAY_CANDWORDS;
             }
         } else {
             if (FcitxHotkeyIsHotKey(sym, state, FCITX_BACKSPACE)) {
-                size_t slen = strlen(keyboard->buffer);
+                size_t slen = strlen(keyboard->buffer[0]);
                 if (slen > 0) {
                     if (keyboard->cursorPos > 0) {
-                        size_t len = fcitx_utf8_strlen(keyboard->buffer);
-                        char *pos = fcitx_utf8_get_nth_char(keyboard->buffer,
+                        size_t len = fcitx_utf8_strlen(keyboard->buffer[0]);
+                        char *pos = fcitx_utf8_get_nth_char(keyboard->buffer[0],
                                                             len - 1);
-                        keyboard->cursorPos = pos - keyboard->buffer;
-                        memset(keyboard->buffer + keyboard->cursorPos,
+                        keyboard->cursorPos = pos - keyboard->buffer[0];
+                        memset(keyboard->buffer[0] + keyboard->cursorPos,
                                0, sizeof(char) * (slen - keyboard->cursorPos));
                         return IRV_DISPLAY_CANDWORDS;
                     } else {
@@ -724,13 +747,13 @@ INPUT_RETURN_VALUE FcitxKeyboardDoInput(void *arg, FcitxKeySym sym, unsigned int
                 return IRV_TO_PROCESS;
         }
 
-        if (strlen(keyboard->buffer) > 0) {
+        if (strlen(keyboard->buffer[0]) > 0) {
             INPUT_RETURN_VALUE irv = IRV_FLAG_FORWARD_KEY;
             if (keyboard->config.bUseEnterToCommit &&
                 FcitxHotkeyIsHotKey(sym, state, FCITX_ENTER)) {
                 irv = 0;
             }
-            FcitxInstanceCommitString(instance, currentIC, keyboard->buffer);
+            FcitxInstanceCommitString(instance, currentIC, keyboard->buffer[0]);
 
             if (result) {
                 char buf[UTF8_MAX_LENGTH + 1];
@@ -776,7 +799,8 @@ INPUT_RETURN_VALUE FcitxKeyboardGetCandWords(void* arg)
     FcitxKeyboard* keyboard = layout->owner;
     FcitxInstance* instance = keyboard->owner;
     FcitxInputState* input = FcitxInstanceGetInputState(instance);
-    if (keyboard->buffer[0] == '\0')
+    keyboard->cursor_moved = false;
+    if (keyboard->buffer[0][0] == '\0')
         return IRV_CLEAN;
 
     static const unsigned int cmodtable[] = {
@@ -788,16 +812,17 @@ INPUT_RETURN_VALUE FcitxKeyboardGetCandWords(void* arg)
     FcitxCandidateWordSetPageSize(mainList, keyboard->config.maximumHintLength);
     FcitxCandidateWordSetChooseAndModifier(
         mainList, DIGIT_STR_CHOOSE, cmodtable[keyboard->config.chooseModifier]);
-    size_t bufferlen = strlen(keyboard->buffer);
+    size_t bufferlen = strlen(keyboard->buffer[0]);
     memcpy(FcitxInputStateGetRawInputBuffer(input),
-           keyboard->buffer, bufferlen + 1);
+           keyboard->buffer[0], bufferlen + 1);
     FcitxInputStateSetRawInputBufferSize(input, bufferlen);
+    FcitxInputStateSetShowCursor(input, true);
     FcitxMessagesAddMessageStringsAtLast(FcitxInputStateGetClientPreedit(input),
-                                         MSG_INPUT, keyboard->buffer);
+                                         MSG_INPUT, keyboard->buffer[0]);
     FcitxInputStateSetClientCursorPos(input, keyboard->cursorPos);
     if (!FcitxInstanceICSupportPreedit(instance, FcitxInstanceGetCurrentIC(instance))) {
         FcitxMessagesAddMessageStringsAtLast(FcitxInputStateGetPreedit(input),
-                                             MSG_INPUT, keyboard->buffer);
+                                             MSG_INPUT, keyboard->buffer[0]);
         FcitxInputStateSetCursorPos(input, keyboard->cursorPos);
     }
 
@@ -805,7 +830,7 @@ INPUT_RETURN_VALUE FcitxKeyboardGetCandWords(void* arg)
         return IRV_DISPLAY_CANDWORDS;
 
     FcitxCandidateWordList *newList;
-    newList = FcitxSpellGetCandWords(instance, NULL, keyboard->buffer, NULL,
+    newList = FcitxSpellGetCandWords(instance, NULL, keyboard->buffer[0], NULL,
                                      keyboard->config.maximumHintLength,
                                      keyboard->dictLang, NULL,
                                      FcitxKeyboardGetCandWordCb, layout);
@@ -822,8 +847,8 @@ void  FcitxKeyboardSave(void *arg)
 
 void  FcitxKeyboardReloadConfig(void *arg)
 {
-    FcitxKeyboardLayout* layout = (FcitxKeyboardLayout*) arg;
-    LoadKeyboardConfig(layout->owner, &layout->owner->config);
+    FcitxKeyboard* keyboard = (FcitxKeyboard*) arg;
+    LoadKeyboardConfig(keyboard, &keyboard->config);
 }
 
 boolean LoadKeyboardConfig(FcitxKeyboard* keyboard, FcitxKeyboardConfig* fs)
@@ -2800,7 +2825,9 @@ checkAlgorithmically(FcitxKeyboardLayout* layout)
     if (keyboard->n_compose >= FCITX_MAX_COMPOSE_LEN)
         return 0;
 
-    for (i = 0; i < keyboard->n_compose && IS_DEAD_KEY(keyboard->composeBuffer[i]); i++);
+    for (i = 0;i < keyboard->n_compose &&
+             IS_DEAD_KEY(keyboard->composeBuffer[i]);i++) {
+    }
     if (i == keyboard->n_compose)
         return INVALID_COMPOSE_RESULT;
 
diff --git a/src/im/keyboard/keyboard.h b/src/im/keyboard/keyboard.h
index efe5374..f0e9cf6 100644
--- a/src/im/keyboard/keyboard.h
+++ b/src/im/keyboard/keyboard.h
@@ -60,7 +60,7 @@ typedef struct _FcitxKeyboard {
     iconv_t iconv;
     char *initialLayout;
     char *initialVariant;
-    char buffer[FCITX_KEYBOARD_MAX_BUFFER + UTF8_MAX_LENGTH + 1];
+    char buffer[2][FCITX_KEYBOARD_MAX_BUFFER + UTF8_MAX_LENGTH + 1];
     int cursorPos;
     uint composeBuffer[FCITX_MAX_COMPOSE_LEN + 1];
     int n_compose;
@@ -68,6 +68,7 @@ typedef struct _FcitxKeyboard {
     int lastLength;
     int dataSlot;
     int enUSRegistered;
+    boolean cursor_moved;
 } FcitxKeyboard;
 
 typedef struct _FcitxKeyboardLayout {
diff --git a/src/im/pinyin/py.c b/src/im/pinyin/py.c
index 204e2f9..9e6900b 100644
--- a/src/im/pinyin/py.c
+++ b/src/im/pinyin/py.c
@@ -53,11 +53,6 @@
 #define PY_INDEX_MAGIC_NUMBER 0xf7462e34
 #define PINYIN_TEMP_FILE "pinyin_XXXXXX"
 
-FCITX_DEFINE_PLUGIN(fcitx_pinyin, ime, FcitxIMClass) = {
-    PYCreate,
-    PYDestroy
-};
-
 typedef struct {
     PY_CAND_WORD_TYPE type;
     ADJUSTORDER order;
@@ -72,6 +67,17 @@ static int PYCandWordCmp(const void* b, const void* a, void* arg);
 static boolean PYGetPYMapByHZ(FcitxPinyinState*pystate, char *strHZ,
                               char* mapHint, char *strMap);
 
+FCITX_DEFINE_PLUGIN(fcitx_pinyin, ime2, FcitxIMClass2) = {
+    PYCreate,
+    PYDestroy,
+    ReloadConfigPY,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+};
+
 DECLARE_ADDFUNCTIONS(Pinyin)
 
 void *PYCreate(FcitxInstance* instance)
@@ -105,7 +111,7 @@ void *PYCreate(FcitxInstance* instance)
                             PYGetCandWords,
                             NULL,
                             SavePY,
-                            ReloadConfigPY,
+                            NULL,
                             NULL,
                             5,
                             "zh_CN");
@@ -120,7 +126,7 @@ void *PYCreate(FcitxInstance* instance)
                             PYGetCandWords,
                             NULL,
                             SavePY,
-                            ReloadConfigPY,
+                            NULL,
                             NULL,
                             5,
                             "zh_CN");
diff --git a/src/lib/fcitx-qt/fcitxqtconnection.cpp b/src/lib/fcitx-qt/fcitxqtconnection.cpp
index 24fc6b6..08a17ea 100644
--- a/src/lib/fcitx-qt/fcitxqtconnection.cpp
+++ b/src/lib/fcitx-qt/fcitxqtconnection.cpp
@@ -28,8 +28,9 @@
 #include "fcitx-utils/utils.h"
 #include <QX11Info>
 #include <QFile>
-#include <qtimer.h>
+#include <QTimer>
 #include <QDir>
+#include <QCoreApplication>
 #include <X11/Xlib.h>
 
 FcitxQtConnection::FcitxQtConnection(QObject* parent): QObject(parent)
diff --git a/src/lib/fcitx-utils/utarray.h b/src/lib/fcitx-utils/utarray.h
index 627315f..ec1d6fe 100644
--- a/src/lib/fcitx-utils/utarray.h
+++ b/src/lib/fcitx-utils/utarray.h
@@ -254,6 +254,10 @@ typedef struct {
         (a)->i -= (len);                                                \
     } while(0)
 
+/**
+ * this actually steal the content away, doesn't destroy the content
+ * so the name doesn't actually accurate, use it carefully.
+ */
 #define utarray_remove_quick(a, pos) do {                               \
         if ((a)->i - 1 != (pos))                                        \
             memcpy(_utarray_eltptr(a, pos), _utarray_eltptr(a, (a)->i - 1), \
@@ -261,6 +265,19 @@ typedef struct {
         (a)->i--;                                                       \
     } while(0)
 
+/**
+ * this is the "real" remove_quick with destroy,
+ */
+#define utarray_remove_quick_full(a, pos) do {                          \
+        if ((a)->icd->dtor) {                                           \
+            (a)->icd->dtor(utarray_eltptr(a, pos));                     \
+        }                                                               \
+        if ((a)->i - 1 != (pos))                                        \
+            memcpy(_utarray_eltptr(a, pos), _utarray_eltptr(a, (a)->i - 1), \
+                   (a)->icd->sz);                                       \
+        (a)->i--;                                                       \
+    } while(0)
+
 #define utarray_clear(a) do {                                   \
         if ((a)->i > 0) {                                       \
             if ((a)->icd->dtor) {                               \
diff --git a/src/lib/fcitx/addon.c b/src/lib/fcitx/addon.c
index 4df36f4..794ad0b 100644
--- a/src/lib/fcitx/addon.c
+++ b/src/lib/fcitx/addon.c
@@ -52,6 +52,7 @@ CONFIG_BINDING_REGISTER("Addon", "IMRegisterMethod", registerMethod)
 CONFIG_BINDING_REGISTER("Addon", "IMRegisterArgument", registerArgument)
 CONFIG_BINDING_REGISTER("Addon", "UIFallback", uifallback)
 CONFIG_BINDING_REGISTER("Addon", "Advance", advance)
+CONFIG_BINDING_REGISTER("Addon", "LoadLocal", loadLocal)
 CONFIG_BINDING_END()
 
 static const UT_icd addon_icd = {
diff --git a/src/lib/fcitx/addon.h b/src/lib/fcitx/addon.h
index d7b580a..0cf59e9 100644
--- a/src/lib/fcitx/addon.h
+++ b/src/lib/fcitx/addon.h
@@ -119,7 +119,12 @@ extern "C" {
             void* dummy2;
         };
 
-        void* padding[8]; /**< padding */
+        union {
+            boolean loadLocal;
+            void* dummy3;
+        };
+
+        void* padding[7]; /**< padding */
     } FcitxAddon;
 
     /**
diff --git a/src/lib/fcitx/candidate-internal.h b/src/lib/fcitx/candidate-internal.h
new file mode 100644
index 0000000..6882486
--- /dev/null
+++ b/src/lib/fcitx/candidate-internal.h
@@ -0,0 +1,45 @@
+/***************************************************************************
+ *   Copyright (C) 2013~2013 by CSSlayer                                   *
+ *   wengxt@gmail.com                                                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef _FCITX_CANDIDATE_INTERNAL_H_
+#define _FCITX_CANDIDATE_INTERNAL_H_
+
+#include "candidate.h"
+
+struct _FcitxCandidateWordList {
+    UT_array candWords;
+    char strChoose[MAX_CAND_WORD + 1];
+    unsigned int candiateModifier;
+    int currentPage;
+    int wordPerPage;
+    boolean hasGonePrevPage;
+    boolean hasGoneNextPage;
+    FcitxCandidateLayoutHint layoutHint;
+    boolean hasPrev;
+    boolean hasNext;
+    FcitxPaging paging;
+    void* overrideArg;
+    FcitxDestroyNotify overrideDestroyNotify;
+    boolean override;
+    boolean overrideHighlight;
+    boolean overrideHighlightValue;
+};
+
+#endif
diff --git a/src/lib/fcitx/candidate.c b/src/lib/fcitx/candidate.c
index c2412c7..395a799 100644
--- a/src/lib/fcitx/candidate.c
+++ b/src/lib/fcitx/candidate.c
@@ -18,24 +18,7 @@
  *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
  ***************************************************************************/
 
-#include "candidate.h"
-
-struct _FcitxCandidateWordList {
-    UT_array candWords;
-    char strChoose[MAX_CAND_WORD + 1];
-    unsigned int candiateModifier;
-    int currentPage;
-    int wordPerPage;
-    boolean hasGonePrevPage;
-    boolean hasGoneNextPage;
-    FcitxCandidateLayoutHint layoutHint;
-    boolean hasPrev;
-    boolean hasNext;
-    FcitxPaging paging;
-    void* overrideArg;
-    FcitxDestroyNotify overrideDestroyNotify;
-    boolean override;
-};
+#include "candidate-internal.h"
 
 static const UT_icd cand_icd = {
     sizeof(FcitxCandidateWord), NULL, NULL, FcitxCandidateWordFree
@@ -161,6 +144,8 @@ void FcitxCandidateWordReset(FcitxCandidateWordList* candList)
         candList->overrideArg = NULL;
         candList->overrideDestroyNotify = NULL;
     }
+    candList->overrideHighlight = false;
+    candList->overrideHighlightValue = false;
     candList->currentPage = 0;
     candList->hasGonePrevPage = false;
     candList->hasGoneNextPage = false;
@@ -492,6 +477,13 @@ void FcitxCandidateWordSetOverridePaging(FcitxCandidateWordList* candList, boole
     candList->overrideDestroyNotify = destroyNotify;
 }
 
+FCITX_EXPORT_API
+void FcitxCandidateWordSetOverrideDefaultHighlight(FcitxCandidateWordList* candList, boolean overrideValue)
+{
+    candList->overrideHighlight = true;
+    candList->overrideHighlightValue = overrideValue;
+}
+
 FCITX_EXPORT_API FcitxCandidateWord*
 FcitxCandidateWordGetFocus(FcitxCandidateWordList *cand_list, boolean clear)
 {
diff --git a/src/lib/fcitx/candidate.h b/src/lib/fcitx/candidate.h
index 088a408..6522253 100644
--- a/src/lib/fcitx/candidate.h
+++ b/src/lib/fcitx/candidate.h
@@ -559,6 +559,8 @@ extern "C" {
      * @param arg arg
      * @param destroyNotify destroyNotify
      * @return void
+     *
+     * @since 4.2.7
      **/
     void FcitxCandidateWordSetOverridePaging(FcitxCandidateWordList* candList,
                                              boolean hasPrev,
@@ -568,6 +570,15 @@ extern "C" {
                                              FcitxDestroyNotify destroyNotify
                                             );
 
+    /**
+     * override default highlight
+     *
+     * @param candList candidate words
+     * @param overrideValue value
+     *
+     * @since 4.2.8
+     */
+    void FcitxCandidateWordSetOverrideDefaultHighlight(FcitxCandidateWordList* candList, boolean overrideValue);
 
 /** convinient string for candidate word */
 #define DIGIT_STR_CHOOSE "1234567890"
diff --git a/src/lib/fcitx/frontend.c b/src/lib/fcitx/frontend.c
index 07941c1..4d17d8e 100644
--- a/src/lib/fcitx/frontend.c
+++ b/src/lib/fcitx/frontend.c
@@ -504,7 +504,7 @@ boolean FcitxInstanceLoadFrontend(FcitxInstance* instance)
                 if (!fp)
                     break;
                 fclose(fp);
-                handle = dlopen(modulePath, RTLD_NOW | RTLD_GLOBAL);
+                handle = dlopen(modulePath, RTLD_NOW | (addon->loadLocal ? RTLD_LOCAL : RTLD_GLOBAL));
                 if (!handle) {
                     FcitxLog(ERROR, _("Frontend: open %s fail %s") , modulePath , dlerror());
                     break;
diff --git a/src/lib/fcitx/ime.c b/src/lib/fcitx/ime.c
index 19c9ad8..36ce1f4 100644
--- a/src/lib/fcitx/ime.c
+++ b/src/lib/fcitx/ime.c
@@ -276,7 +276,7 @@ void FcitxInstanceLoadIM(FcitxInstance* instance, FcitxAddon* addon)
             return;
         }
         fclose(fp);
-        handle = dlopen(modulePath, RTLD_NOW | RTLD_GLOBAL);
+        handle = dlopen(modulePath, RTLD_NOW | (addon->loadLocal ? RTLD_LOCAL : RTLD_GLOBAL));
         if (!handle) {
             FcitxLog(ERROR, _("IM: open %s fail %s") , modulePath , dlerror());
             free(modulePath);
@@ -1136,7 +1136,8 @@ void FcitxInstanceReloadAddonConfig(FcitxInstance *instance, const char* addonna
         FcitxInstanceLoadAllIM(instance);
     } else {
         do {
-            FcitxIM* im = FcitxInstanceGetIMByName(instance, addonname);
+            FcitxIM* im;
+            im = FcitxInstanceGetIMByName(instance, addonname);
             if (im && im->ReloadConfig) {
                 im->ReloadConfig(im->klass);
                 break;
@@ -1157,6 +1158,21 @@ void FcitxInstanceReloadAddonConfig(FcitxInstance *instance, const char* addonna
                 case AC_FRONTEND:
                     if (addon->frontend->ReloadConfig)
                         addon->frontend->ReloadConfig(addon->addonInstance);
+                case AC_INPUTMETHOD:
+                    /* imclass and imclass2 are in same union, only check one of them */
+                    if (addon->imclass) {
+                        for (im = (FcitxIM*) utarray_front(&instance->availimes);
+                             im != NULL;
+                             im = (FcitxIM*) utarray_next(&instance->availimes, im)) {
+                            if (im->owner == addon && im->ReloadConfig) {
+                                im->ReloadConfig(im->klass);
+                            }
+                        }
+
+                        if (addon->isIMClass2 && addon->imclass2->ReloadConfig) {
+                            addon->imclass2->ReloadConfig(addon->addonInstance);
+                        }
+                    }
                     break;
                 default:
                     break;
diff --git a/src/lib/fcitx/ime.h b/src/lib/fcitx/ime.h
index 5676495..24f18f6 100644
--- a/src/lib/fcitx/ime.h
+++ b/src/lib/fcitx/ime.h
@@ -174,7 +174,7 @@ extern "C" {
          * this behavior cannot be overrided), it give im a chance to choose remember this
          * word or not.
          *
-         * Input method need to notice, that the commit is already DONE, do not to extra commit.
+         * Input method need to notice, that the commit is already DONE, do not do extra commit.
          */
         CET_LostFocus,
         /**
diff --git a/src/lib/fcitx/module.c b/src/lib/fcitx/module.c
index 74ffe01..70e50f0 100644
--- a/src/lib/fcitx/module.c
+++ b/src/lib/fcitx/module.c
@@ -56,7 +56,7 @@ void FcitxModuleLoad(FcitxInstance* instance)
                 if (!fp)
                     break;
                 fclose(fp);
-                handle = dlopen(modulePath, RTLD_NOW | RTLD_GLOBAL);
+                handle = dlopen(modulePath, RTLD_NOW | (addon->loadLocal ? RTLD_LOCAL : RTLD_GLOBAL));
                 if (!handle) {
                     FcitxLog(ERROR, _("Module: open %s fail %s") , modulePath , dlerror());
                     break;
diff --git a/src/lib/fcitx/module.h b/src/lib/fcitx/module.h
index 28de64f..bae6601 100644
--- a/src/lib/fcitx/module.h
+++ b/src/lib/fcitx/module.h
@@ -109,7 +109,7 @@ extern "C" {
     void* FcitxModuleInvokeFunction(FcitxAddon* addon, int functionId, FcitxModuleFunctionArg args);
 #define FcitxModuleInvokeVaArgs(addon, functionId, ARGV...)             \
     (FcitxModuleInvokeFunction(addon, functionId,                       \
-                               (FcitxModuleFunctionArg){ .args = {ARGV} }))
+                               (FcitxModuleFunctionArg){ {ARGV} }))
 
     /**
      * invoke inter module function with addon name, returns NULL when fails (the function itself can also return NULL)
@@ -133,7 +133,7 @@ extern "C" {
 #define InvokeVaArgs(INST, MODULE, FUNC, ARGV...)                       \
     ((MODULE##_##FUNC##_RETURNTYPE)FcitxModuleInvokeFunctionByName(     \
         INST, MODULE##_NAME, MODULE##_##FUNC,                           \
-        (FcitxModuleFunctionArg){ .args = {ARGV} }))
+        (FcitxModuleFunctionArg){ {ARGV} }))
 
 /** add a function to a addon */
 #define AddFunction(ADDON, Realname)                                    \
@@ -215,7 +215,7 @@ extern "C" {
     }
 
 #define FCITX_DEF_MODULE_ARGS(var, ARGV...)             \
-    FcitxModuleFunctionArg var = { .args = {ARGV} }
+    FcitxModuleFunctionArg var = { {ARGV} }
     /* void *__##var##_array[] = {ARGV};                                   \ */
     /* size_t __##var##_length = sizeof(__##var##_array) / sizeof(void*);  \ */
     /* FcitxModuleFunctionArg var[] = { { .n = __##var##_length,           \ */
diff --git a/src/lib/fcitx/ui.c b/src/lib/fcitx/ui.c
index 548fef3..d4944dc 100644
--- a/src/lib/fcitx/ui.c
+++ b/src/lib/fcitx/ui.c
@@ -37,6 +37,7 @@
 #include "instance-internal.h"
 #include "addon-internal.h"
 #include "ui-internal.h"
+#include "candidate-internal.h"
 
 /**
  * @file ui.c
@@ -185,7 +186,7 @@ boolean FcitxUILoadInternal(FcitxInstance* instance, FcitxAddon* addon)
 
         fclose(fp);
 
-        handle = dlopen(modulePath, RTLD_NOW | RTLD_GLOBAL);
+        handle = dlopen(modulePath, RTLD_NOW | (addon->loadLocal ? RTLD_LOCAL : RTLD_GLOBAL));
 
         if (!handle) {
             FcitxLog(ERROR, _("UI: open %s fail %s") , modulePath , dlerror());
@@ -764,6 +765,15 @@ void FcitxUIGetMainWindowSize(FcitxInstance* instance, int* x, int* y, int* w, i
         instance->ui->ui->MainWindowSizeHint(instance->ui->addonInstance, x, y, w, h);
 }
 
+static inline boolean FcitxUIUseDefaultHighlight(FcitxInstance* instance, FcitxCandidateWordList* candList)
+{
+    if (candList->overrideHighlight) {
+        return candList->overrideHighlightValue;
+    } else {
+        return !FcitxInstanceGetContextBoolean(instance, CONTEXT_DISABLE_AUTO_FIRST_CANDIDATE_HIGHTLIGHT);
+    }
+}
+
 FCITX_EXPORT_API
 int FcitxUINewMessageToOldStyleMessage(FcitxInstance* instance, FcitxMessages* msgUp, FcitxMessages* msgDown)
 {
@@ -811,7 +821,7 @@ int FcitxUINewMessageToOldStyleMessage(FcitxInstance* instance, FcitxMessages* m
         if (i == 0
             && FcitxCandidateWordGetCurrentPage(input->candList) == 0
             && type == MSG_OTHER
-            && !FcitxInstanceGetContextBoolean(instance, CONTEXT_DISABLE_AUTO_FIRST_CANDIDATE_HIGHTLIGHT)
+            && FcitxUIUseDefaultHighlight(instance, input->candList)
         )
             type = MSG_FIRSTCAND;
 
diff --git a/src/lib/fcitx/ui.h b/src/lib/fcitx/ui.h
index fac782e..2c7bd26 100644
--- a/src/lib/fcitx/ui.h
+++ b/src/lib/fcitx/ui.h
@@ -94,7 +94,7 @@ extern "C" {
     /** fcitx menu item type */
     typedef enum _FcitxMenuItemType {
         MENUTYPE_SIMPLE,
-        MENUTYPE_SUBMENU,
+        MENUTYPE_SUBMENU,/**< unfortunately this is only used internal, don't use it in your code */
         MENUTYPE_DIVLINE
     } FcitxMenuItemType;
 
diff --git a/src/module/CMakeLists.txt b/src/module/CMakeLists.txt
index 79b6dde..2bfbb85 100644
--- a/src/module/CMakeLists.txt
+++ b/src/module/CMakeLists.txt
@@ -28,3 +28,4 @@ add_subdirectory(vk)
 add_subdirectory(dbus)
 add_subdirectory(lua)
 add_subdirectory(unicode)
+add_subdirectory(notificationitem)
diff --git a/src/module/autoeng/AutoEng.c b/src/module/autoeng/AutoEng.c
index 4364c41..c92329f 100644
--- a/src/module/autoeng/AutoEng.c
+++ b/src/module/autoeng/AutoEng.c
@@ -69,6 +69,9 @@ typedef struct _FcitxAutoEngState {
     boolean auto_space;
     FcitxInstance *owner;
     FcitxAutoEngConfig config;
+    boolean cursor_moved;
+    char *back_buff;
+    size_t back_buff_size;
 } FcitxAutoEngState;
 
 static const unsigned int cmodtable[] = {
@@ -161,16 +164,11 @@ FCITX_DEFINE_PLUGIN(fcitx_autoeng, module ,FcitxModule) = {
 };
 
 static void
-AutoEngSetBuffLen(FcitxAutoEngState* autoEngState, size_t len)
+AutoEngSetBuffLen(FcitxAutoEngState *autoEngState, size_t len)
 {
-    unsigned int size = (len / MAX_USER_INPUT + 1) * MAX_USER_INPUT;
-    if (autoEngState->buf) {
-        if (autoEngState->buff_size != size) {
-            autoEngState->buf = realloc(autoEngState->buf, size);
-            autoEngState->buff_size = size;
-        }
-    } else {
-        autoEngState->buf = malloc(size);
+    unsigned int size = fcitx_utils_align_to(len + 1, MAX_USER_INPUT);
+    if (autoEngState->buff_size != size) {
+        autoEngState->buf = realloc(autoEngState->buf, size);
         autoEngState->buff_size = size;
     }
     autoEngState->buf[len] = '\0';
@@ -191,6 +189,17 @@ AutoEngSetBuff(FcitxAutoEngState* autoEngState, const char *str, char extra)
     }
 }
 
+static void
+AutoEngSwapBuff(FcitxAutoEngState* autoEngState)
+{
+    size_t tmp_size = autoEngState->buff_size;
+    char *tmp_buf = autoEngState->buf;
+    autoEngState->buf = autoEngState->back_buff;
+    autoEngState->buff_size = autoEngState->back_buff_size;
+    autoEngState->back_buff = tmp_buf;
+    autoEngState->back_buff_size = tmp_size;
+}
+
 static boolean
 AutoEngCheckAutoSpace(FcitxAutoEngState *autoEngState, char key)
 {
@@ -311,59 +320,81 @@ AutoEngCheckSelect(FcitxAutoEngState *autoEngState,
     int key;
     FcitxCandidateWord *cand_word;
     if (FcitxHotkeyIsHotKey(sym, state, fc->nextWord)) {
-        cand_word = FcitxCandidateWordGetFocus(cand_list, true);
-        cand_word = FcitxCandidateWordGetNext(cand_list, cand_word);
-        if (!cand_word) {
-            FcitxCandidateWordSetPage(cand_list, 0);
-            cand_word = FcitxCandidateWordGetFirst(cand_list);
+        if (!autoEngState->cursor_moved) {
+            cand_word = FcitxCandidateWordGetCurrentWindow(cand_list);
         } else {
-            FcitxCandidateWordSetFocus(
-                cand_list, FcitxCandidateWordGetIndex(cand_list, cand_word));
+            cand_word = FcitxCandidateWordGetFocus(cand_list, true);
+            cand_word = FcitxCandidateWordGetNext(cand_list, cand_word);
+            if (!cand_word) {
+                FcitxCandidateWordSetPage(cand_list, 0);
+            } else {
+                FcitxCandidateWordSetFocus(
+                    cand_list, FcitxCandidateWordGetIndex(cand_list,
+                                                          cand_word));
+            }
         }
     } else if (FcitxHotkeyIsHotKey(sym, state, fc->prevWord)) {
-        cand_word = FcitxCandidateWordGetFocus(cand_list, true);
-        cand_word = FcitxCandidateWordGetPrev(cand_list, cand_word);
-        if (!cand_word) {
-            FcitxCandidateWordSetPage(
-                cand_list, FcitxCandidateWordPageCount(cand_list) - 1);
-            cand_word = FcitxCandidateWordGetLast(cand_list);
+        if (!autoEngState->cursor_moved) {
+            cand_word = FcitxCandidateWordGetByIndex(
+                cand_list,
+                FcitxCandidateWordGetCurrentWindowSize(cand_list) - 1);
         } else {
-            FcitxCandidateWordSetFocus(
-                cand_list, FcitxCandidateWordGetIndex(cand_list, cand_word));
+            cand_word = FcitxCandidateWordGetFocus(cand_list, true);
+            cand_word = FcitxCandidateWordGetPrev(cand_list, cand_word);
+            if (cand_word) {
+                FcitxCandidateWordSetFocus(
+                    cand_list, FcitxCandidateWordGetIndex(cand_list,
+                                                          cand_word));
+            }
         }
     } else if (FcitxHotkeyIsHotKey(sym, state,
                                    FcitxConfigPrevPageKey(instance, fc))) {
+        boolean has_prev_page;
         cand_word = FcitxCandidateWordGetFocus(cand_list, true);
-        if (!FcitxCandidateWordGoPrevPage(cand_list)) {
-            FcitxCandidateWordSetType(cand_word, MSG_CANDIATE_CURSOR);
-            return IRV_TO_PROCESS;
+        has_prev_page = FcitxCandidateWordGoPrevPage(cand_list);
+        if (!autoEngState->cursor_moved) {
+            cand_word = NULL;
+        } else if (has_prev_page) {
+            cand_word = FcitxCandidateWordGetCurrentWindow(cand_list) +
+                FcitxCandidateWordGetCurrentWindowSize(cand_list) - 1;
         }
-        cand_word = FcitxCandidateWordGetCurrentWindow(cand_list) +
-            FcitxCandidateWordGetCurrentWindowSize(cand_list) - 1;
     } else if (FcitxHotkeyIsHotKey(sym, state,
                                    FcitxConfigNextPageKey(instance, fc))) {
+        boolean has_next_page;
         cand_word = FcitxCandidateWordGetFocus(cand_list, true);
-        if (!FcitxCandidateWordGoNextPage(cand_list)) {
-            FcitxCandidateWordSetType(cand_word, MSG_CANDIATE_CURSOR);
-            return IRV_TO_PROCESS;
+        has_next_page = FcitxCandidateWordGoNextPage(cand_list);
+        if (!autoEngState->cursor_moved) {
+            cand_word = NULL;
+        } else if (has_next_page) {
+            cand_word = FcitxCandidateWordGetCurrentWindow(cand_list);
         }
-        cand_word = FcitxCandidateWordGetCurrentWindow(cand_list);
     } else if ((key = FcitxCandidateWordCheckChooseKey(cand_list,
                                                        sym, state)) >= 0) {
         return FcitxCandidateWordChooseByIndex(cand_list, key);
     } else {
         return IRV_TO_PROCESS;
     }
-    FcitxCandidateWordSetType(cand_word, MSG_CANDIATE_CURSOR);
-    AutoEngSetBuff(autoEngState, cand_word->strWord, '\0');
+    if (cand_word) {
+        FcitxCandidateWordSetType(cand_word, MSG_CANDIATE_CURSOR);
+        if (!autoEngState->cursor_moved)
+            AutoEngSwapBuff(autoEngState);
+        AutoEngSetBuff(autoEngState, cand_word->strWord, '\0');
+        autoEngState->cursor_moved = true;
+    } else if (autoEngState->cursor_moved) {
+        AutoEngSwapBuff(autoEngState);
+        autoEngState->cursor_moved = false;
+    } else {
+        return IRV_FLAG_UPDATE_INPUT_WINDOW;
+    }
     FcitxMessages *client_preedit = FcitxInputStateGetClientPreedit(input);
     FcitxMessages *preedit = FcitxInputStateGetPreedit(input);
     FcitxMessagesSetMessageCount(client_preedit, 0);
+    FcitxMessagesSetMessageCount(preedit, 0);
     FcitxMessagesAddMessageStringsAtLast(client_preedit, MSG_INPUT,
                                          autoEngState->buf);
-    FcitxMessagesSetMessageCount(preedit, 0);
     FcitxMessagesAddMessageStringsAtLast(preedit, MSG_INPUT,
                                          autoEngState->buf);
+    FcitxInputStateSetCursorPos(input, autoEngState->index);
     FcitxInputStateSetClientCursorPos(input, autoEngState->index);
     return IRV_FLAG_UPDATE_INPUT_WINDOW;
 }
@@ -377,6 +408,17 @@ AutoEngCommit(FcitxAutoEngState *autoEngState)
     AutoEngSetBuffLen(autoEngState, 0);
 }
 
+static void
+AutoEngActivate(FcitxAutoEngState *autoEngState, FcitxInputState* input,
+                INPUT_RETURN_VALUE *retval)
+{
+    FcitxInputStateSetShowCursor(input, false);
+    *retval = IRV_DISPLAY_MESSAGE;
+    autoEngState->active = true;
+    autoEngState->cursor_moved = false;
+    ShowAutoEngMessage(autoEngState, retval);
+}
+
 static boolean PreInputProcessAutoEng(void* arg, FcitxKeySym sym,
                                       unsigned int state,
                                       INPUT_RETURN_VALUE *retval)
@@ -394,10 +436,7 @@ static boolean PreInputProcessAutoEng(void* arg, FcitxKeySym sym,
             AutoEngSetBuff(autoEngState,
                            FcitxInputStateGetRawInputBuffer(input), keymain);
             if (SwitchToEng(autoEngState, autoEngState->buf)) {
-                *retval = IRV_DISPLAY_MESSAGE;
-                FcitxInputStateSetShowCursor(input, false);
-                autoEngState->active = true;
-                ShowAutoEngMessage(autoEngState, retval);
+                AutoEngActivate(autoEngState, input, retval);
                 return true;
             }
         }
@@ -441,12 +480,9 @@ boolean PostInputProcessAutoEng(void* arg, FcitxKeySym sym, unsigned int state,
         (FcitxInputStateGetRawInputBufferSize(input) != 0 ||
          (FcitxInputStateGetKeyState(input) & FcitxKeyState_CapsLock) == 0) &&
         AutoEngCheckPreedit(autoEngState)) {
-        *retval = IRV_DISPLAY_MESSAGE;
-        FcitxInputStateSetShowCursor(input, false);
         AutoEngSetBuff(autoEngState, FcitxInputStateGetRawInputBuffer(input),
                        FcitxHotkeyPadToMain(sym));
-        autoEngState->active = true;
-        ShowAutoEngMessage(autoEngState, retval);
+        AutoEngActivate(autoEngState, input, retval);
         return true;
     }
 
@@ -460,6 +496,7 @@ void ResetAutoEng(void *arg)
     autoEngState->index = 0;
     AutoEngSetBuffLen(autoEngState, 0);
     autoEngState->active = false;
+    autoEngState->cursor_moved = false;
 }
 
 static CONFIG_DESC_DEFINE(GetAutoEngConfigDesc, "fcitx-autoeng.desc");
@@ -537,6 +574,8 @@ void FreeAutoEng(void* arg)
         utarray_free(autoEngState->autoEng);
         autoEngState->autoEng = NULL;
     }
+    fcitx_utils_free(autoEngState->buf);
+    fcitx_utils_free(autoEngState->back_buff);
 }
 
 boolean SwitchToEng(FcitxAutoEngState *autoEngState, const char *str)
@@ -590,6 +629,7 @@ AutoEngGetSpellHint(FcitxAutoEngState *autoEngState)
     if (candList) {
         FcitxInputState *input = FcitxInstanceGetInputState(autoEngState->owner);
         FcitxCandidateWordList *iList = FcitxInputStateGetCandidateList(input);
+        FcitxCandidateWordSetOverrideDefaultHighlight(iList, false);
         FcitxCandidateWordSetChooseAndModifier(
             iList, DIGIT_STR_CHOOSE,
             cmodtable[autoEngState->config.chooseModifier]);
diff --git a/src/module/chttrans/chttrans-opencc.c b/src/module/chttrans/chttrans-opencc.c
index e1386a9..dc44b0e 100644
--- a/src/module/chttrans/chttrans-opencc.c
+++ b/src/module/chttrans/chttrans-opencc.c
@@ -41,6 +41,10 @@ OpenCCInit(FcitxChttrans* transState)
 {
     if (transState->ods2t || transState->odt2s)
         return true;
+    if (transState->openccLoaded)
+        return false;
+    transState->openccLoaded = true;
+
     if (!OpenCCLoadLib())
         return false;
     transState->ods2t = _opencc_open(_OPENCC_DEFAULT_CONFIG_SIMP_TO_TRAD);
diff --git a/src/module/chttrans/chttrans.c b/src/module/chttrans/chttrans.c
index 85e672d..e40ce1f 100644
--- a/src/module/chttrans/chttrans.c
+++ b/src/module/chttrans/chttrans.c
@@ -244,11 +244,12 @@ char *ConvertGBKSimple2Tradition(FcitxChttrans* transState, const char *strHZ)
     switch (transState->engine) {
     case ENGINE_OPENCC:
 #ifdef ENABLE_OPENCC
-        {
+        do {
             if (transState->ods2t == NULL) {
                 OpenCCInit(transState);
                 if (transState->ods2t == NULL) {
-                    return NULL;
+                    /* break to native as fallback */
+                    break;
                 }
             }
 
@@ -259,7 +260,7 @@ char *ConvertGBKSimple2Tradition(FcitxChttrans* transState, const char *strHZ)
             }
 
             return res;
-        }
+        } while(0);
 #endif
     case ENGINE_NATIVE: {
         FILE           *fp;
diff --git a/src/module/chttrans/chttrans_p.h b/src/module/chttrans/chttrans_p.h
index 7d1e081..7b6effb 100644
--- a/src/module/chttrans/chttrans_p.h
+++ b/src/module/chttrans/chttrans_p.h
@@ -31,6 +31,7 @@ typedef struct _FcitxChttrans {
     void* ods2t;
     void* odt2s;
     FcitxInstance* owner;
+    boolean openccLoaded;
 } FcitxChttrans;
 
 #endif // CHTTRANS_P_H
diff --git a/src/module/clipboard/clipboard.c b/src/module/clipboard/clipboard.c
index 5ca2c68..e5dbb0a 100644
--- a/src/module/clipboard/clipboard.c
+++ b/src/module/clipboard/clipboard.c
@@ -348,6 +348,7 @@ ClipboardPostHook(void *arg, FcitxKeySym sym, unsigned int state,
     FcitxCandidateWordSetPageSize(cand_list, page_size);
     FcitxCandidateWordSetChooseAndModifier(
         cand_list, DIGIT_STR_CHOOSE, cmodifiers[config->choose_modifier]);
+    FcitxCandidateWordSetOverrideDefaultHighlight(cand_list, false);
     if (clipboard->clp_hist_len) {
         ClipboardSetCandWord(clipboard, &cand_word, clipboard->clp_hist_lst);
         FcitxCandidateWordAppend(cand_list, &cand_word);
@@ -378,6 +379,8 @@ skip_primary:
         FcitxCandidateWordAppend(cand_list, &cand_word);
     }
     *ret_val = IRV_FLAG_UPDATE_INPUT_WINDOW;
+    FcitxCandidateWordSetType(FcitxCandidateWordGetFirst(cand_list),
+                              MSG_CANDIATE_CURSOR);
     return true;
 }
 
diff --git a/src/module/dbusstuff/property.c b/src/module/dbusstuff/property.c
new file mode 100644
index 0000000..2b0e408
--- /dev/null
+++ b/src/module/dbusstuff/property.c
@@ -0,0 +1,150 @@
+/***************************************************************************
+ *   Copyright (C) 2013~2013 by CSSlayer                                   *
+ *   wengxt@gmail.com                                                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#include <string.h>
+
+#include <dbus/dbus.h>
+#include "property.h"
+
+DBusMessage* FcitxDBusPropertyGet(void* arg, const FcitxDBusPropertyTable* propertTable, DBusMessage* message)
+{
+    DBusError error;
+    dbus_error_init(&error);
+    char *interface;
+    char *property;
+    DBusMessage* reply = NULL;
+    if (dbus_message_get_args(message, &error,
+                              DBUS_TYPE_STRING, &interface,
+                              DBUS_TYPE_STRING, &property,
+                              DBUS_TYPE_INVALID)) {
+        int index = 0;
+        while (propertTable[index].interface != NULL) {
+            if (strcmp(propertTable[index].interface, interface) == 0
+                    && strcmp(propertTable[index].name, property) == 0)
+                break;
+            index ++;
+        }
+
+        if (propertTable[index].interface) {
+            DBusMessageIter args, variant;
+            reply = dbus_message_new_method_return(message);
+            dbus_message_iter_init_append(reply, &args);
+            dbus_message_iter_open_container(&args, DBUS_TYPE_VARIANT, propertTable[index].type, &variant);
+            if (propertTable[index].getfunc)
+                propertTable[index].getfunc(arg, &variant);
+            dbus_message_iter_close_container(&args, &variant);
+        }
+        else {
+            reply = dbus_message_new_error_printf(message, DBUS_ERROR_UNKNOWN_PROPERTY, "No such property ('%s.%s')", interface, property);
+        }
+    }
+    else {
+        reply = FcitxDBusPropertyUnknownMethod(message);
+    }
+
+    return reply;
+}
+
+DBusMessage* FcitxDBusPropertySet(void* arg, const FcitxDBusPropertyTable* propertTable, DBusMessage* message)
+{
+    DBusError error;
+    dbus_error_init(&error);
+    char *interface;
+    char *property;
+    DBusMessage* reply = NULL;
+
+    DBusMessageIter args, variant;
+    dbus_message_iter_init(message, &args);
+
+    if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_STRING)
+        goto dbus_property_set_end;
+
+    dbus_message_iter_get_basic(&args, &interface);
+    dbus_message_iter_next(&args);
+
+    if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_STRING)
+        goto dbus_property_set_end;
+    dbus_message_iter_get_basic(&args, &property);
+    dbus_message_iter_next(&args);
+
+    if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_VARIANT)
+        goto dbus_property_set_end;
+
+    dbus_message_iter_recurse(&args, &variant);
+    int index = 0;
+    while (propertTable[index].interface != NULL) {
+        if (strcmp(propertTable[index].interface, interface) == 0
+                && strcmp(propertTable[index].name, property) == 0)
+            break;
+        index ++;
+    }
+    if (propertTable[index].setfunc) {
+        propertTable[index].setfunc(arg, &variant);
+        reply = dbus_message_new_method_return(message);
+    }
+    else {
+        reply = dbus_message_new_error_printf(message, DBUS_ERROR_UNKNOWN_PROPERTY, "No such property ('%s.%s')", interface, property);
+    }
+
+dbus_property_set_end:
+    if (!reply)
+        reply = FcitxDBusPropertyUnknownMethod(message);
+
+    return reply;
+}
+
+DBusMessage* FcitxDBusPropertyGetAll(void* arg, const FcitxDBusPropertyTable* propertTable, DBusMessage* message)
+{
+    DBusError error;
+    dbus_error_init(&error);
+    char *interface;
+    DBusMessage* reply = NULL;
+    if (dbus_message_get_args(message, &error,
+                              DBUS_TYPE_STRING, &interface,
+                              DBUS_TYPE_INVALID)) {
+        reply = dbus_message_new_method_return(message);
+        int index = 0;
+        DBusMessageIter args;
+        dbus_message_iter_init_append(reply, &args);
+        DBusMessageIter array, entry;
+        dbus_message_iter_open_container(&args, DBUS_TYPE_ARRAY, "{sv}", &array);
+
+        while (propertTable[index].interface != NULL) {
+            if (strcmp(propertTable[index].interface, interface) == 0 && propertTable[index].getfunc) {
+                dbus_message_iter_open_container(&array, DBUS_TYPE_DICT_ENTRY,
+                                                 NULL, &entry);
+
+                dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &propertTable[index].name);
+                DBusMessageIter variant;
+                dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT, propertTable[index].type, &variant);
+                propertTable[index].getfunc(arg, &variant);
+                dbus_message_iter_close_container(&entry, &variant);
+
+                dbus_message_iter_close_container(&array, &entry);
+            }
+            index ++;
+        }
+        dbus_message_iter_close_container(&args, &array);
+    }
+    if (!reply)
+        reply = FcitxDBusPropertyUnknownMethod(message);
+
+    return reply;
+}
diff --git a/src/module/dbusstuff/property.h b/src/module/dbusstuff/property.h
new file mode 100644
index 0000000..bf94235
--- /dev/null
+++ b/src/module/dbusstuff/property.h
@@ -0,0 +1,47 @@
+/***************************************************************************
+ *   Copyright (C) 2013~2013 by CSSlayer                                   *
+ *   wengxt@gmail.com                                                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef FCITX_DBUSSTUFF_PROPERTY_H
+#define FCITX_DBUSSTUFF_PROPERTY_H
+
+#include <dbus/dbus.h>
+
+typedef struct _FcitxDBusPropertyTable {
+    char* interface;
+    char* name;
+    char* type;
+    void (*getfunc)(void* arg, DBusMessageIter* iter);
+    void (*setfunc)(void* arg, DBusMessageIter* iter);
+} FcitxDBusPropertyTable;
+
+DBusMessage* FcitxDBusPropertyGet(void* arg, const FcitxDBusPropertyTable* propertTable, DBusMessage* message);
+DBusMessage* FcitxDBusPropertySet(void* arg, const FcitxDBusPropertyTable* propertTable, DBusMessage* message);
+DBusMessage* FcitxDBusPropertyGetAll(void* arg, const FcitxDBusPropertyTable* propertTable, DBusMessage* message);
+
+static inline DBusMessage* FcitxDBusPropertyUnknownMethod(DBusMessage *msg)
+{
+    DBusMessage* reply = dbus_message_new_error_printf(msg,
+                                                       DBUS_ERROR_UNKNOWN_METHOD,
+                                                       "No such method with signature (%s)",
+                                                       dbus_message_get_signature(msg));
+    return reply;
+}
+
+#endif // FCITX_DBUSSTUFF_PROPERTY_H
diff --git a/src/module/lua/CMakeLists.txt b/src/module/lua/CMakeLists.txt
index 5f9c113..13452b3 100644
--- a/src/module/lua/CMakeLists.txt
+++ b/src/module/lua/CMakeLists.txt
@@ -1,5 +1,5 @@
 if(ENABLE_LUA)
-  find_package(Lua REQUIRED)
+  find_package(Lua 5.1 REQUIRED)
   include_directories(${LUA_INCLUDE_DIRS})
   set(lua_noinstall)
 else()
diff --git a/src/module/notificationitem/CMakeLists.txt b/src/module/notificationitem/CMakeLists.txt
new file mode 100644
index 0000000..dee5a27
--- /dev/null
+++ b/src/module/notificationitem/CMakeLists.txt
@@ -0,0 +1,18 @@
+if(_ENABLE_DBUS)
+  include_directories(
+    ${DBUS_INCLUDE_DIRS})
+  link_directories(${DBUS_LIBRARY_DIRS})
+else()
+  set(notificationitem_noinstall NO_INSTALL)
+endif()
+
+set(FCITX_NOTIFICATIONITEM_SOURCES
+    notificationitem.c
+    dbusmenu.c
+    ../dbusstuff/property.c)
+fcitx_add_addon_full(notificationitem ${notificationitem_noinstall}
+  SCAN SCAN_PRIV
+  HEADERS notificationitem.h
+  SOURCES ${FCITX_NOTIFICATIONITEM_SOURCES}
+  LINK_LIBS ${DBUS_LIBRARIES})
+
diff --git a/src/module/notificationitem/dbusmenu.c b/src/module/notificationitem/dbusmenu.c
new file mode 100644
index 0000000..0f301ea
--- /dev/null
+++ b/src/module/notificationitem/dbusmenu.c
@@ -0,0 +1,720 @@
+/***************************************************************************
+ *   Copyright (C) 2013~2013 by CSSlayer                                   *
+ *   wengxt@gmail.com                                                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#include <libintl.h>
+
+#include "module/dbusstuff/property.h"
+#include "notificationitem_p.h"
+#include "fcitx-utils/utils.h"
+#include "fcitx/fcitx.h"
+
+/*
+ * libdbusmenu-gtk have a strange 30000 limitation, in order to leverage this, we need
+ * some more hack
+ *
+ * max bit -> 14bit
+ * lower 5 bit for menu, 0 -> 31 (IMHO it's enough)
+ * higher 9 bit for index, 0 -> 511
+ */
+
+#define DBUS_MENU_IFACE "com.canonical.dbusmenu"
+#define ACTION_ID(ID, IDX) (((IDX) << 5) | (ID))
+#define ACTION_INDEX(ID) (((ID) & 0xffffffe0) >> 5)
+#define ACTION_MENU(ID) ((ID) & 0x0000001f)
+#define STATUS_ID(ISCOMP, IDX) ACTION_ID(0, (((ISCOMP) ? 0x100 : 0x000) + IDX + 8 + 1))
+#define STATUS_INDEX(ID) ((ACTION_INDEX(ID) & 0x1ff) - 8 - 1)
+#define STATUS_ISCOMP(ID) (!!(ACTION_INDEX(ID) & 0x100))
+
+static const UT_icd ut_int32_icd = {
+    sizeof(int32_t), NULL, NULL, NULL
+};
+
+const char* dbus_menu_interface =
+    "<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\""
+    "\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">"
+    "<node>"
+    "<interface name=\"" DBUS_INTERFACE_INTROSPECTABLE "\">"
+    "<method name=\"Introspect\">"
+    "<arg name=\"data\" direction=\"out\" type=\"s\"/>"
+    "</method>"
+    "</interface>"
+    "<interface name=\"" DBUS_INTERFACE_PROPERTIES "\">"
+    "<method name=\"Get\">"
+    "<arg name=\"interface_name\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"property_name\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"value\" direction=\"out\" type=\"v\"/>"
+    "</method>"
+    "<method name=\"Set\">"
+    "<arg name=\"interface_name\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"property_name\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"value\" direction=\"in\" type=\"v\"/>"
+    "</method>"
+    "<method name=\"GetAll\">"
+    "<arg name=\"interface_name\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"values\" direction=\"out\" type=\"a{sv}\"/>"
+    "</method>"
+    "<signal name=\"PropertiesChanged\">"
+    "<arg name=\"interface_name\" type=\"s\"/>"
+    "<arg name=\"changed_properties\" type=\"a{sv}\"/>"
+    "<arg name=\"invalidated_properties\" type=\"as\"/>"
+    "</signal>"
+    "</interface>"
+    "<interface name=\"com.canonical.dbusmenu\">"
+    "<property name=\"Version\" type=\"u\" access=\"read\"/>"
+    "<property name=\"Status\" type=\"s\" access=\"read\"/>"
+    "<signal name=\"ItemsPropertiesUpdated\">"
+    "<arg type=\"a(ia{sv})\" direction=\"out\"/>"
+    "<arg type=\"a(ias)\" direction=\"out\"/>"
+    "</signal>"
+    "<signal name=\"LayoutUpdated\">"
+    "<arg name=\"revision\" type=\"u\" direction=\"out\"/>"
+    "<arg name=\"parentId\" type=\"i\" direction=\"out\"/>"
+    "</signal>"
+    "<signal name=\"ItemActivationRequested\">"
+    "<arg name=\"id\" type=\"i\" direction=\"out\"/>"
+    "<arg name=\"timeStamp\" type=\"u\" direction=\"out\"/>"
+    "</signal>"
+    "<method name=\"Event\">"
+    "<arg name=\"id\" type=\"i\" direction=\"in\"/>"
+    "<arg name=\"eventId\" type=\"s\" direction=\"in\"/>"
+    "<arg name=\"data\" type=\"v\" direction=\"in\"/>"
+    "<arg name=\"timestamp\" type=\"u\" direction=\"in\"/>"
+    "<annotation name=\"org.freedesktop.DBus.Method.NoReply\" value=\"true\"/>"
+    "</method>"
+    "<method name=\"GetProperty\">"
+    "<arg type=\"v\" direction=\"out\"/>"
+    "<arg name=\"id\" type=\"i\" direction=\"in\"/>"
+    "<arg name=\"property\" type=\"s\" direction=\"in\"/>"
+    "</method>"
+    "<method name=\"GetLayout\">"
+    "<arg type=\"u\" direction=\"out\"/>"
+    "<arg name=\"parentId\" type=\"i\" direction=\"in\"/>"
+    "<arg name=\"recursionDepth\" type=\"i\" direction=\"in\"/>"
+    "<arg name=\"propertyNames\" type=\"as\" direction=\"in\"/>"
+    "<arg name=\"item\" type=\"(ia{sv}av)\" direction=\"out\"/>"
+    "</method>"
+    "<method name=\"GetGroupProperties\">"
+    "<arg type=\"a(ia{sv})\" direction=\"out\"/>"
+    "<arg name=\"ids\" type=\"ai\" direction=\"in\"/>"
+    "<arg name=\"propertyNames\" type=\"as\" direction=\"in\"/>"
+    "</method>"
+    "<method name=\"AboutToShow\">"
+    "<arg type=\"b\" direction=\"out\"/>"
+    "<arg name=\"id\" type=\"i\" direction=\"in\"/> "
+    "</method>"
+    "</interface>"
+    "</node>";
+
+static DBusHandlerResult FcitxDBusMenuEventHandler (DBusConnection  *connection,
+                                                    DBusMessage     *message,
+                                                    void            *user_data);
+
+static void FcitxDBusMenuGetVersion(void* arg, DBusMessageIter* iter);
+static void FcitxDBusMenuGetStatus(void* arg, DBusMessageIter* iter);
+static void FcitxDBusMenuEvent(FcitxNotificationItem* notificationitem, DBusMessage* message);
+static DBusMessage* FcitxDBusMenuGetGroupProperties(FcitxNotificationItem* notificationitem, DBusMessage* message);
+static DBusMessage* FcitxDBusMenuGetProperty(FcitxNotificationItem* notificationitem, DBusMessage* message);
+static DBusMessage* FcitxDBusMenuAboutToShow(FcitxNotificationItem* notificationitem, DBusMessage* message);
+static DBusMessage* FcitxDBusMenuGetLayout(FcitxNotificationItem* notificationitem, DBusMessage* message);
+static void FcitxDBusMenuFillLayooutItemWrap(FcitxNotificationItem* notificationitem, int32_t id, int depth, FcitxStringHashSet* properties, DBusMessageIter* iter);
+static void FcitxDBusMenuFillLayooutItem(FcitxNotificationItem* notificationitem, int32_t id, int depth, FcitxStringHashSet* properties, DBusMessageIter* iter);
+
+const FcitxDBusPropertyTable dbusMenuPropertyTable[] = {
+    { DBUS_MENU_IFACE, "Version", "u", FcitxDBusMenuGetVersion, NULL },
+    { DBUS_MENU_IFACE, "Status", "s", FcitxDBusMenuGetStatus, NULL },
+    { NULL, NULL, NULL, NULL, NULL }
+};
+
+boolean FcitxDBusMenuCreate(FcitxNotificationItem* notificationitem)
+{
+    DBusObjectPathVTable fcitxIPCVTable = {NULL, &FcitxDBusMenuEventHandler, NULL, NULL, NULL, NULL };
+    if (dbus_connection_register_object_path(notificationitem->conn, "/MenuBar", &fcitxIPCVTable, notificationitem)) {
+        return true;
+    }
+    return false;
+}
+
+DBusHandlerResult FcitxDBusMenuEventHandler(DBusConnection* connection, DBusMessage* message, void* user_data)
+{
+    FcitxNotificationItem* notificationitem = user_data;
+    DBusHandlerResult result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    DBusMessage *reply = NULL;
+    boolean flush = false;
+    if (dbus_message_is_method_call(message, DBUS_INTERFACE_INTROSPECTABLE, "Introspect")) {
+        reply = dbus_message_new_method_return(message);
+        dbus_message_append_args(reply, DBUS_TYPE_STRING, &dbus_menu_interface, DBUS_TYPE_INVALID);
+    } else if (dbus_message_is_method_call(message, DBUS_MENU_IFACE, "Event")) {
+        /* this is no reply */
+        FcitxDBusMenuEvent(notificationitem, message);
+        return DBUS_HANDLER_RESULT_HANDLED;
+    } else if (dbus_message_is_method_call(message, DBUS_MENU_IFACE, "GetProperty")) {
+        reply = FcitxDBusMenuGetProperty(notificationitem, message);
+    } else if (dbus_message_is_method_call(message, DBUS_MENU_IFACE, "GetLayout")) {
+        reply = FcitxDBusMenuGetLayout(notificationitem, message);
+    } else if (dbus_message_is_method_call(message, DBUS_MENU_IFACE, "GetGroupProperties")) {
+        reply = FcitxDBusMenuGetGroupProperties(notificationitem, message);
+    } else if (dbus_message_is_method_call(message, DBUS_MENU_IFACE, "AboutToShow")) {
+        reply = FcitxDBusMenuAboutToShow(notificationitem, message);
+    } else if (dbus_message_is_method_call(message, DBUS_INTERFACE_PROPERTIES, "Get")) {
+        reply = FcitxDBusPropertyGet(notificationitem, dbusMenuPropertyTable, message);
+    } else if (dbus_message_is_method_call(message, DBUS_INTERFACE_PROPERTIES, "Set")) {
+        reply = FcitxDBusPropertySet(notificationitem, dbusMenuPropertyTable, message);
+    } else if (dbus_message_is_method_call(message, DBUS_INTERFACE_PROPERTIES, "GetAll")) {
+        reply = FcitxDBusPropertyGetAll(notificationitem, dbusMenuPropertyTable, message);
+    }
+
+    if (reply) {
+        dbus_connection_send(connection, reply, NULL);
+        dbus_message_unref(reply);
+        if (flush) {
+            dbus_connection_flush(connection);
+        }
+        result = DBUS_HANDLER_RESULT_HANDLED;
+    }
+    return result;
+}
+
+void FcitxDBusMenuDoEvent(void* arg)
+{
+    FcitxNotificationItem* notificationitem = (FcitxNotificationItem*) arg;
+    FcitxInstance* instance = notificationitem->owner;
+
+    int32_t id = notificationitem->pendingActionId;
+    notificationitem->pendingActionId = -1;
+
+    int32_t menu = ACTION_MENU(id);
+    int32_t index = ACTION_INDEX(id);
+    if (index <= 0)
+        return;
+
+    if (menu == 0) {
+        if (index <= 8 && index > 0) {
+            switch(index) {
+                case 1:
+                    {
+                        char* args[] = {
+                            "xdg-open",
+                            "http://fcitx-im.org/",
+                            0
+                        };
+                        fcitx_utils_start_process(args);
+                    }
+                    break;
+                case 4:
+                    {
+                        FcitxIM* im = FcitxInstanceGetCurrentIM(instance);
+                        if (im && im->owner) {
+                            fcitx_utils_launch_configure_tool_for_addon(im->uniqueName);
+                        }
+                        else {
+                            fcitx_utils_launch_configure_tool();
+                        }
+                    }
+                    break;
+                case 5:
+                    fcitx_utils_launch_configure_tool();
+                    break;
+                case 6:
+                    fcitx_utils_launch_restart();
+                    break;
+                case 7:
+                    FcitxInstanceEnd(instance);
+                    break;
+            }
+        } else {
+            int index = STATUS_INDEX(id);
+            const char* name = NULL;
+            if (STATUS_ISCOMP(id)) {
+                UT_array* uicompstats = FcitxInstanceGetUIComplexStats(instance);
+                FcitxUIComplexStatus* compstatus = (FcitxUIComplexStatus*) utarray_eltptr(uicompstats, index);
+                if (compstatus) {
+                    name = compstatus->name;
+                }
+            } else {
+                UT_array* uistats = FcitxInstanceGetUIStats(instance);
+                FcitxUIStatus* status = (FcitxUIStatus*) utarray_eltptr(uistats, index);
+                if (status) {
+                    name = status->name;
+                }
+            }
+            if (name) {
+                FcitxUIUpdateStatus(instance, name);
+            }
+        }
+    } else if (menu > 0) {
+        UT_array* uimenus = FcitxInstanceGetUIMenus(instance);
+        FcitxUIMenu** menup = (FcitxUIMenu**) utarray_eltptr(uimenus, menu - 1), *menu;
+        if (!menup)
+            return;
+        menu = *menup;
+        if (menu->MenuAction) {
+            menu->MenuAction(menu, index - 1);
+        }
+    }
+}
+
+void FcitxDBusMenuEvent(FcitxNotificationItem* notificationitem, DBusMessage* message)
+{
+    /* signature isvu */
+    DBusMessageIter args;
+    dbus_message_iter_init(message, &args);
+
+    int32_t id;
+    char* type;
+    do {
+        if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_INT32)
+            break;
+        dbus_message_iter_get_basic(&args, &id);
+        dbus_message_iter_next(&args);
+        if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_STRING)
+            break;
+        dbus_message_iter_get_basic(&args, &type);
+        dbus_message_iter_next(&args);
+        if (strcmp(type, "clicked") != 0)
+            break;
+        /* TODO parse variant, but no one actually use this */
+        if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_VARIANT)
+            break;
+        dbus_message_iter_next(&args);
+        /* timestamp, useless for us */
+        if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_UINT32)
+            break;
+        dbus_message_iter_next(&args);
+
+        if (!FcitxInstanceCheckTimeoutByFunc(notificationitem->owner, FcitxDBusMenuDoEvent)) {
+            notificationitem->pendingActionId = id;
+            FcitxInstanceAddTimeout(notificationitem->owner, 50, FcitxDBusMenuDoEvent, notificationitem);
+        }
+    } while(0);
+}
+
+void FcitxDBusMenuAppendProperty(DBusMessageIter* iter, FcitxStringHashSet* properties, const char* name, int type, const void* data) {
+    if (properties && !fcitx_utils_string_hash_set_contains(properties, name))
+        return;
+    DBusMessageIter entry;
+    dbus_message_iter_open_container(iter, DBUS_TYPE_DICT_ENTRY, NULL, &entry);
+    dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &name);
+    DBusMessageIter variant;
+    char typeString[2] = {(char)type, '\0'};
+    dbus_message_iter_open_container(&entry, DBUS_TYPE_VARIANT, typeString, &variant);
+    dbus_message_iter_append_basic(&variant, type, data);
+    dbus_message_iter_close_container(&entry, &variant);
+
+    dbus_message_iter_close_container(iter, &entry);
+}
+
+void FcitxDBusMenuFillProperty(FcitxNotificationItem* notificationitem, int32_t id, FcitxStringHashSet* properties, DBusMessageIter* iter)
+{
+    FcitxInstance* instance = notificationitem->owner;
+    /* append a{sv} */
+    DBusMessageIter sub;
+    dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY, "{sv}", &sub);
+    int32_t menu = ACTION_MENU(id);
+    int32_t index = ACTION_INDEX(id);
+
+    /* index == 0 means it has a sub menu */
+    if (index == 0) {
+        const char* value = "submenu";
+        FcitxDBusMenuAppendProperty(&sub, properties, "children-display", DBUS_TYPE_STRING, &value);
+    }
+    if (menu == 0) {
+        if (index <= 8 && index > 0) {
+            const char* value;
+            switch(index) {
+                case 1:
+                    value = _("Online Help");
+                    FcitxDBusMenuAppendProperty(&sub, properties, "label", DBUS_TYPE_STRING, &value);
+                    value = "help-contents";
+                    FcitxDBusMenuAppendProperty(&sub, properties, "icon-name", DBUS_TYPE_STRING, &value);
+                    break;
+                case 2:
+                case 3:
+                case 8:
+                    value = "separator";
+                    FcitxDBusMenuAppendProperty(&sub, properties, "type", DBUS_TYPE_STRING, &value);
+                    break;
+                case 4:
+                    value = _("Configure Current Input Method");
+                    FcitxDBusMenuAppendProperty(&sub, properties, "label", DBUS_TYPE_STRING, &value);
+                    break;
+                case 5:
+                    value = _("Configure");
+                    FcitxDBusMenuAppendProperty(&sub, properties, "label", DBUS_TYPE_STRING, &value);
+                    /* this icon sucks on KDE, why configure doesn't have "configure" */
+#if 0
+                    value = "preferences-system";
+                    FcitxDBusMenuAppendProperty(&sub, properties, "icon-name", DBUS_TYPE_STRING, &value);
+#endif
+                    break;
+                case 6:
+                    value = _("Restart");
+                    FcitxDBusMenuAppendProperty(&sub, properties, "label", DBUS_TYPE_STRING, &value);
+                    value = "view-refresh";
+                    FcitxDBusMenuAppendProperty(&sub, properties, "icon-name", DBUS_TYPE_STRING, &value);
+                    break;
+                case 7:
+                    value = _("Exit");
+                    FcitxDBusMenuAppendProperty(&sub, properties, "label", DBUS_TYPE_STRING, &value);
+                    value = "application-exit";
+                    FcitxDBusMenuAppendProperty(&sub, properties, "icon-name", DBUS_TYPE_STRING, &value);
+                    break;
+            }
+        } else {
+            int index = STATUS_INDEX(id);
+            const char* name = NULL;
+            const char* icon = NULL;
+            char* needfree = NULL;
+            if (STATUS_ISCOMP(id)) {
+                UT_array* uicompstats = FcitxInstanceGetUIComplexStats(instance);
+                FcitxUIComplexStatus* compstatus = (FcitxUIComplexStatus*) utarray_eltptr(uicompstats, index);
+                if (compstatus) {
+                    name = compstatus->shortDescription;
+                    icon = compstatus->getIconName(compstatus->arg);
+                }
+            } else {
+                UT_array* uistats = FcitxInstanceGetUIStats(instance);
+                FcitxUIStatus* status = (FcitxUIStatus*) utarray_eltptr(uistats, index);
+                if (status) {
+                    name = status->shortDescription;
+
+                    fcitx_utils_alloc_cat_str(needfree, "fcitx-", status->name,
+                                            ((status->getCurrentStatus(status->arg)) ?
+                                            "-active" : "-inactive"));
+                    icon = needfree;
+                }
+            }
+
+            if (name) {
+                FcitxDBusMenuAppendProperty(&sub, properties, "label", DBUS_TYPE_STRING, &name);
+            }
+            if (icon) {
+                FcitxDBusMenuAppendProperty(&sub, properties, "icon-name", DBUS_TYPE_STRING, &icon);
+            }
+            fcitx_utils_free(needfree);
+        }
+    } else {
+        UT_array* uimenus = FcitxInstanceGetUIMenus(instance);
+        FcitxUIMenu** menupp = (FcitxUIMenu**) utarray_eltptr(uimenus, menu - 1), *menup;
+        if (menupp) {
+            menup = *menupp;
+            if (index == 0) {
+                FcitxDBusMenuAppendProperty(&sub, properties, "label", DBUS_TYPE_STRING, &menup->name);
+            } else if (index > 0) {
+                FcitxMenuItem* item = (FcitxMenuItem*) utarray_eltptr(&menup->shell, index - 1);
+                if (item) {
+                    FcitxDBusMenuAppendProperty(&sub, properties, "label", DBUS_TYPE_STRING, &item->tipstr);
+                    if (menup->mark != -1) {
+                        const char* radio = "radio";
+                        FcitxDBusMenuAppendProperty(&sub, properties, "toggle-type", DBUS_TYPE_STRING, &radio);
+                        int32_t toggleState = 0;
+                        if (menup->mark == index - 1) {
+                            toggleState = 1;
+                        }
+                        FcitxDBusMenuAppendProperty(&sub, properties, "toggle-state", DBUS_TYPE_INT32, &toggleState);
+                    }
+                }
+            }
+        }
+    }
+    dbus_message_iter_close_container(iter, &sub);
+}
+
+void FcitxDBusMenuFillLayooutItemWrap(FcitxNotificationItem* notificationitem, int32_t id, int depth, FcitxStringHashSet* properties, DBusMessageIter* iter)
+{
+    DBusMessageIter variant;
+    dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT, "(ia{sv}av)", &variant);
+    FcitxDBusMenuFillLayooutItem(notificationitem, id, depth, properties, &variant);
+    dbus_message_iter_close_container(iter, &variant);
+}
+
+void FcitxDBusMenuFillLayooutItem(FcitxNotificationItem* notificationitem, int32_t id, int depth, FcitxStringHashSet* properties, DBusMessageIter* iter)
+{
+    FcitxInstance* instance = notificationitem->owner;
+    DBusMessageIter sub, array;
+    dbus_message_iter_open_container(iter, DBUS_TYPE_STRUCT, NULL, &sub);
+    dbus_message_iter_append_basic(&sub, DBUS_TYPE_INT32, &id);
+    FcitxDBusMenuFillProperty(notificationitem, id, properties, &sub);
+
+    dbus_message_iter_open_container(&sub, DBUS_TYPE_ARRAY, "v", &array);
+
+    /* for dbus menu, we have
+     * root (0,0) -> online help (0,1)
+     *            -> separator (0,2)
+     *            -> some status (0,8 + X) do cache
+     *            -> separator (0,8)
+     *            -> registered menu (x,0) -> (x,1) , (x,2), (x,3)
+     *            -> separator (0,3)
+     *            -> configure current (0,4)
+     *            -> configure (0,5)
+     *            -> restart (0,6)
+     *            -> exit (0,7)
+     */
+
+    /* using != 0 can make -1 recursive to infinite */
+    if (depth != 0) {
+        int32_t menu = ACTION_MENU(id);
+        int32_t index = ACTION_INDEX(id);
+
+        UT_array* uimenus = FcitxInstanceGetUIMenus(instance);
+        /* we ONLY support submenu in top level menu */
+        if (menu == 0) {
+            if (index == 0) {
+                FcitxDBusMenuFillLayooutItemWrap(notificationitem, ACTION_ID(0,1), depth - 1, properties, &array);
+                FcitxDBusMenuFillLayooutItemWrap(notificationitem, ACTION_ID(0,2), depth - 1, properties, &array);
+                boolean flag = false;
+
+                /* copied from classicui.c */
+                FcitxUIStatus* status;
+                UT_array* uistats = FcitxInstanceGetUIStats(instance);
+                int i;
+                for (i = 0, status = (FcitxUIStatus*) utarray_front(uistats);
+                     status != NULL;
+                     i++, status = (FcitxUIStatus*) utarray_next(uistats, status)) {
+                    if (!status->visible)
+                        continue;
+
+                    flag = true;
+                    FcitxDBusMenuFillLayooutItemWrap(notificationitem, STATUS_ID(0,i), depth - 1, properties, &array);
+                }
+
+                FcitxUIComplexStatus* compstatus;
+                UT_array* uicompstats = FcitxInstanceGetUIComplexStats(instance);
+                for (i = 0, compstatus = (FcitxUIComplexStatus*) utarray_front(uicompstats);
+                     compstatus != NULL;
+                     i++, compstatus = (FcitxUIComplexStatus*) utarray_next(uicompstats, compstatus)
+                    ) {
+                    if (!compstatus->visible)
+                        continue;
+                    if (FcitxUIGetMenuByStatusName(instance, compstatus->name))
+                        continue;
+
+                    flag = true;
+                    FcitxDBusMenuFillLayooutItemWrap(notificationitem, STATUS_ID(1,i), depth - 1, properties, &array);
+                }
+
+                if (flag)
+                    FcitxDBusMenuFillLayooutItemWrap(notificationitem, ACTION_ID(0,8), depth - 1, properties, &array);
+                if (utarray_len(uimenus) > 0) {
+                    FcitxUIMenu **menupp;
+                    int i = 1;
+                    for (menupp = (FcitxUIMenu **) utarray_front(uimenus);
+                         menupp != NULL;
+                         menupp = (FcitxUIMenu **) utarray_next(uimenus, menupp)) {
+                        FcitxDBusMenuFillLayooutItemWrap(notificationitem, ACTION_ID(i,0), depth - 1, properties, &array);
+                        i ++;
+                    }
+                    FcitxDBusMenuFillLayooutItemWrap(notificationitem, ACTION_ID(0,3), depth - 1, properties, &array);
+                }
+                FcitxDBusMenuFillLayooutItemWrap(notificationitem, ACTION_ID(0,4), depth - 1, properties, &array);
+                FcitxDBusMenuFillLayooutItemWrap(notificationitem, ACTION_ID(0,5), depth - 1, properties, &array);
+                FcitxDBusMenuFillLayooutItemWrap(notificationitem, ACTION_ID(0,6), depth - 1, properties, &array);
+                FcitxDBusMenuFillLayooutItemWrap(notificationitem, ACTION_ID(0,7), depth - 1, properties, &array);
+            }
+        } else {
+            if (index == 0) {
+                FcitxUIMenu** menupp = (FcitxUIMenu**) utarray_eltptr(uimenus, menu - 1), *menup;
+                if (menupp) {
+                    menup = *menupp;
+                    menup->UpdateMenu(menup);
+
+                    unsigned int i = 0;
+                    unsigned int len = utarray_len(&menup->shell);
+                    for (i = 0; i < len; i++) {
+                        FcitxDBusMenuFillLayooutItemWrap(notificationitem, ACTION_ID(menu,i + 1), depth - 1, properties, &array);
+                    }
+                }
+            }
+        }
+    }
+    dbus_message_iter_close_container(&sub, &array);
+    dbus_message_iter_close_container(iter, &sub);
+}
+
+DBusMessage* FcitxDBusMenuGetLayout(FcitxNotificationItem* notificationitem, DBusMessage* message)
+{
+    /* signature iias */
+    DBusMessageIter args;
+    dbus_message_iter_init(message, &args);
+
+    DBusMessage* reply = NULL;
+
+    int32_t id, recursionDepth;
+    do {
+        if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_INT32)
+            break;
+        dbus_message_iter_get_basic(&args, &id);
+        dbus_message_iter_next(&args);
+
+        if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_INT32)
+            break;
+        dbus_message_iter_get_basic(&args, &recursionDepth);
+        dbus_message_iter_next(&args);
+
+        if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_ARRAY)
+            break;
+
+        DBusMessageIter sub;
+        dbus_message_iter_recurse(&args, &sub);
+        FcitxStringHashSet* properties = NULL;
+        while (dbus_message_iter_get_arg_type(&sub) == DBUS_TYPE_STRING) {
+            char* property;
+            dbus_message_iter_get_basic(&sub, &property);
+
+            if (!fcitx_utils_string_hash_set_contains(properties, property)) {
+                properties = fcitx_utils_string_hash_set_insert(properties, property);
+            }
+            dbus_message_iter_next(&sub);
+        }
+
+        reply = dbus_message_new_method_return(message);
+
+        /* out put is u(ia{sv}av) */
+        DBusMessageIter iter;
+        dbus_message_iter_init_append(reply, &iter);
+        dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &notificationitem->revision);
+        FcitxDBusMenuFillLayooutItem(notificationitem, id, recursionDepth, properties, &iter);
+
+        fcitx_utils_free_string_hash_set(properties);
+    } while(0);
+
+    if (!reply) {
+        reply = FcitxDBusPropertyUnknownMethod(message);
+    }
+
+    return reply;
+}
+
+DBusMessage* FcitxDBusMenuGetProperty(FcitxNotificationItem* notificationitem, DBusMessage* message)
+{
+    /* TODO implement this, document said this only for debug so we ignore it for now */
+
+    /* signature is */
+    DBusMessage* reply = NULL;
+    reply = FcitxDBusPropertyUnknownMethod(message);
+
+    return reply;
+}
+
+DBusMessage* FcitxDBusMenuGetGroupProperties(FcitxNotificationItem* notificationitem, DBusMessage* message)
+{
+    /* signature aias */
+    DBusMessageIter args;
+    dbus_message_iter_init(message, &args);
+
+    DBusMessage* reply = NULL;
+
+    do {
+        if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_ARRAY)
+            break;
+
+        DBusMessageIter sub;
+        dbus_message_iter_recurse(&args, &sub);
+        UT_array ids;
+        utarray_init(&ids, &ut_int32_icd);
+        while (dbus_message_iter_get_arg_type(&sub) == DBUS_TYPE_INT32) {
+            int32_t id;
+            dbus_message_iter_get_basic(&sub, &id);
+
+            utarray_push_back(&ids, &id);
+            dbus_message_iter_next(&sub);
+        }
+        dbus_message_iter_next(&args);
+
+        dbus_message_iter_recurse(&args, &sub);
+        FcitxStringHashSet* properties = NULL;
+        if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_ARRAY) {
+            utarray_done(&ids);
+            break;
+        }
+
+        while (dbus_message_iter_get_arg_type(&sub) == DBUS_TYPE_STRING) {
+            char* property;
+            dbus_message_iter_get_basic(&sub, &property);
+
+            if (!fcitx_utils_string_hash_set_contains(properties, property)) {
+                properties = fcitx_utils_string_hash_set_insert(properties, property);
+            }
+            dbus_message_iter_next(&sub);
+        }
+
+        reply = dbus_message_new_method_return(message);
+
+        /* out put is a(ia{sv}) */
+        DBusMessageIter iter;
+        dbus_message_iter_init_append(reply, &iter);
+        dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, "(ia{sv})", &sub);
+        int i = 0;
+        for (; i < utarray_len(&ids); i ++) {
+            int32_t id = *(int32_t*) utarray_eltptr(&ids, i);
+            DBusMessageIter ssub;
+            dbus_message_iter_open_container(&sub, DBUS_TYPE_STRUCT, NULL, &ssub);
+            dbus_message_iter_append_basic(&ssub, DBUS_TYPE_INT32, &id);
+            FcitxDBusMenuFillProperty(notificationitem, id, properties, &ssub);
+            dbus_message_iter_close_container(&sub, &ssub);
+        }
+        dbus_message_iter_close_container(&iter, &sub);
+
+        utarray_done(&ids);
+        fcitx_utils_free_string_hash_set(properties);
+    } while(0);
+
+    if (!reply) {
+        reply = FcitxDBusPropertyUnknownMethod(message);
+    }
+
+    return reply;
+}
+
+DBusMessage* FcitxDBusMenuAboutToShow(FcitxNotificationItem* notificationitem, DBusMessage* message)
+{
+    DBusMessage* reply = NULL;
+    /* signature i out b */
+    int32_t id;
+    DBusError err;
+    dbus_error_init(&err);
+    if (dbus_message_get_args(message, &err, DBUS_TYPE_INT32, &id, DBUS_TYPE_INVALID)) {
+        reply = dbus_message_new_method_return(message);
+        /* for fcitx, we always return true */
+        dbus_bool_t needUpdate = TRUE;
+        dbus_message_append_args(reply, DBUS_TYPE_BOOLEAN, &needUpdate, DBUS_TYPE_INVALID);
+        notificationitem->revision++;
+        DBusMessage* sig = dbus_message_new_signal("/MenuBar", DBUS_MENU_IFACE, "LayoutUpdated");
+        dbus_message_append_args(sig, DBUS_TYPE_UINT32, &notificationitem->revision, DBUS_TYPE_INT32, &id, DBUS_TYPE_INVALID);
+        dbus_connection_send(notificationitem->conn, sig, NULL);
+        dbus_message_unref(sig);
+    } else {
+        reply = FcitxDBusPropertyUnknownMethod(message);
+    }
+
+    dbus_error_free(&err);
+    return reply;
+}
+
+void FcitxDBusMenuGetVersion(void* arg, DBusMessageIter* iter)
+{
+    unsigned int version = 2;
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &version);
+}
+
+void FcitxDBusMenuGetStatus(void* arg, DBusMessageIter* iter)
+{
+    const char* status = "normal";
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &status);
+}
diff --git a/src/module/notificationitem/fcitx-notificationitem.conf.in b/src/module/notificationitem/fcitx-notificationitem.conf.in
new file mode 100644
index 0000000..cd67dde
--- /dev/null
+++ b/src/module/notificationitem/fcitx-notificationitem.conf.in
@@ -0,0 +1,11 @@
+[Addon]
+Name=fcitx-notificationitem
+_GeneralName=DBus based new Freedesktop.org tray icon
+_Comment=DBus based new Freedesktop.org tray icon
+Category=Module
+Enabled=True
+Library=fcitx-notificationitem.so
+Type=SharedLibrary
+Priority=80
+Dependency=fcitx-dbus
+Advance=True
diff --git a/src/module/notificationitem/fcitx-notificationitem.fxaddon b/src/module/notificationitem/fcitx-notificationitem.fxaddon
new file mode 100644
index 0000000..1053b27
--- /dev/null
+++ b/src/module/notificationitem/fcitx-notificationitem.fxaddon
@@ -0,0 +1,25 @@
+[FcitxAddon]
+Name=fcitx-notificationitem
+Prefix=NotificationItem
+Include0="notificationitem.h"
+Function0=Enable
+Function1=Disable
+Function2=
+Function3=
+Function4=
+Function5=
+Function6=
+Function7=
+Function8=
+Self.Type=FcitxNotificationItem*
+
+[Enable]
+Name=enable
+Arg0=FcitxNotificationItemAvailableCallback
+Arg1=void*
+Return=boolean
+Res.WrapFunc=FcitxNotificationItemEnable
+
+[Disable]
+Name=disable
+Res.WrapFunc=FcitxNotificationItemDisable
diff --git a/src/module/notificationitem/notificationitem.c b/src/module/notificationitem/notificationitem.c
new file mode 100644
index 0000000..03527a8
--- /dev/null
+++ b/src/module/notificationitem/notificationitem.c
@@ -0,0 +1,623 @@
+/***************************************************************************
+ *   Copyright (C) 2013~2013 by CSSlayer                                   *
+ *   wengxt@gmail.com                                                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#include <dbus/dbus.h>
+#include "config.h"
+#include "fcitx/fcitx.h"
+
+#include "libintl.h"
+#include "module/dbus/fcitx-dbus.h"
+#include "module/dbusstuff/property.h"
+#include "notificationitem.h"
+#include "notificationitem_p.h"
+#include "fcitx-utils/log.h"
+#include "fcitx/module.h"
+#include "fcitx/hook.h"
+
+const char * _notification_item =
+"<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
+"<node name=\"/StatusNotifierItem\">"
+"<interface name=\"" DBUS_INTERFACE_INTROSPECTABLE "\">"
+"<method name=\"Introspect\">"
+"<arg name=\"data\" direction=\"out\" type=\"s\"/>"
+"</method>"
+"</interface>"
+"<interface name=\"" DBUS_INTERFACE_PROPERTIES "\">"
+"<method name=\"Get\">"
+"<arg name=\"interface_name\" direction=\"in\" type=\"s\"/>"
+"<arg name=\"property_name\" direction=\"in\" type=\"s\"/>"
+"<arg name=\"value\" direction=\"out\" type=\"v\"/>"
+"</method>"
+"<method name=\"Set\">"
+"<arg name=\"interface_name\" direction=\"in\" type=\"s\"/>"
+"<arg name=\"property_name\" direction=\"in\" type=\"s\"/>"
+"<arg name=\"value\" direction=\"in\" type=\"v\"/>"
+"</method>"
+"<method name=\"GetAll\">"
+"<arg name=\"interface_name\" direction=\"in\" type=\"s\"/>"
+"<arg name=\"values\" direction=\"out\" type=\"a{sv}\"/>"
+"</method>"
+"<signal name=\"PropertiesChanged\">"
+"<arg name=\"interface_name\" type=\"s\"/>"
+"<arg name=\"changed_properties\" type=\"a{sv}\"/>"
+"<arg name=\"invalidated_properties\" type=\"as\"/>"
+"</signal>"
+"</interface>"
+"<interface name=\"org.kde.StatusNotifierItem\">"
+"<property name=\"Id\" type=\"s\" access=\"read\" />"
+"<property name=\"Category\" type=\"s\" access=\"read\" />"
+"<property name=\"Status\" type=\"s\" access=\"read\" />"
+"<property name=\"IconName\" type=\"s\" access=\"read\" />"
+"<property name=\"AttentionIconName\" type=\"s\" access=\"read\" />"
+"<property name=\"Title\" type=\"s\" access=\"read\" />"
+"<property access=\"read\" type=\"(sa(iiay)ss)\" name=\"ToolTip\" />"
+"<property name=\"IconThemePath\" type=\"s\" access=\"read\" />"
+"<property name=\"Menu\" type=\"o\" access=\"read\" />"
+"<property name=\"XAyatanaLabel\" type=\"s\" access=\"read\" />"
+"<property name=\"XAyatanaLabelGuide\" type=\"s\" access=\"read\" />"
+"<property name=\"XAyatanaOrderingIndex\" type=\"u\" access=\"read\" />"
+"<method name=\"Scroll\">"
+"<arg type=\"i\" name=\"delta\" direction=\"in\" />"
+"<arg type=\"s\" name=\"orientation\" direction=\"in\" />"
+"</method>"
+"<method name=\"Activate\">"
+"<arg type=\"i\" name=\"x\" direction=\"in\" />"
+"<arg type=\"i\" name=\"y\" direction=\"in\" />"
+"</method>"
+"<method name=\"SecondaryActivate\">"
+"<arg type=\"i\" name=\"x\" direction=\"in\" />"
+"<arg type=\"i\" name=\"y\" direction=\"in\" />"
+"</method>"
+"<signal name=\"NewIcon\">"
+"</signal>"
+"<signal name=\"NewToolTip\">"
+"</signal>"
+"<signal name=\"NewIconThemePath\">"
+"<arg type=\"s\" name=\"icon_theme_path\" direction=\"out\" />"
+"</signal>"
+"<signal name=\"NewAttentionIcon\">"
+"</signal>"
+"<signal name=\"NewStatus\">"
+"<arg type=\"s\" name=\"status\" direction=\"out\" />"
+"</signal>"
+"<signal name=\"NewTitle\">"
+"</signal>"
+"<signal name=\"XAyatanaNewLabel\">"
+"<arg type=\"s\" name=\"label\" direction=\"out\" />"
+"<arg type=\"s\" name=\"guide\" direction=\"out\" />"
+"</signal>"
+"</interface>"
+"</node>"
+;
+
+#define NOTIFICATION_WATCHER_DBUS_ADDR    "org.kde.StatusNotifierWatcher"
+#define NOTIFICATION_WATCHER_DBUS_OBJ     "/StatusNotifierWatcher"
+#define NOTIFICATION_WATCHER_DBUS_IFACE   "org.kde.StatusNotifierWatcher"
+
+#define NOTIFICATION_ITEM_DBUS_IFACE      "org.kde.StatusNotifierItem"
+#define NOTIFICATION_ITEM_DEFAULT_OBJ     "/StatusNotifierItem"
+
+static void* FcitxNotificationItemCreate(struct _FcitxInstance* instance);
+static void FcitxNotificationItemDestroy(void* arg);
+
+FCITX_DEFINE_PLUGIN(fcitx_notificationitem, module, FcitxModule) = {
+    FcitxNotificationItemCreate,
+    FcitxNotificationItemDestroy,
+    NULL,
+    NULL,
+    NULL
+};
+
+static DBusHandlerResult FcitxNotificationItemEventHandler (DBusConnection  *connection,
+                                                            DBusMessage     *message,
+                                                            void            *user_data);
+
+static void NotificationWatcherServiceExistCallback(DBusPendingCall *call, void *data);
+static void FcitxNotificationItemRegisterSuccess(DBusPendingCall *call, void *data);
+
+static void FcitxNotificationItemGetId(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemGetCategory(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemGetStatus(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemGetIconName(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemGetAttentionIconName(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemGetTitle(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemGetIconThemePath(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemGetMenu(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemGetToolTip(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemGetXAyatanaLabel(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemGetXAyatanaLabelGuide(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemGetXAyatanaOrderingIndex(void* arg, DBusMessageIter* iter);
+static void FcitxNotificationItemIMChanged(void* arg);
+static boolean FcitxNotificationItemEnable(FcitxNotificationItem* notificationitem, FcitxNotificationItemAvailableCallback callback, void *data);
+static void FcitxNotificationItemDisable(FcitxNotificationItem* notificationitem);
+static DBusHandlerResult FcitxNotificationItemDBusFilter(DBusConnection* connection, DBusMessage* msg, void* user_data);
+static void FcitxNotificationItemSetAvailable(FcitxNotificationItem* notificationitem, boolean available);
+
+
+const FcitxDBusPropertyTable propertTable[] = {
+    { NOTIFICATION_ITEM_DBUS_IFACE, "Id", "s", FcitxNotificationItemGetId, NULL },
+    { NOTIFICATION_ITEM_DBUS_IFACE, "Category", "s", FcitxNotificationItemGetCategory, NULL },
+    { NOTIFICATION_ITEM_DBUS_IFACE, "Status", "s", FcitxNotificationItemGetStatus, NULL },
+    { NOTIFICATION_ITEM_DBUS_IFACE, "IconName", "s", FcitxNotificationItemGetIconName, NULL },
+    { NOTIFICATION_ITEM_DBUS_IFACE, "AttentionIconName", "s", FcitxNotificationItemGetAttentionIconName, NULL },
+    { NOTIFICATION_ITEM_DBUS_IFACE, "Title", "s", FcitxNotificationItemGetTitle, NULL },
+    { NOTIFICATION_ITEM_DBUS_IFACE, "IconThemePath", "s", FcitxNotificationItemGetIconThemePath, NULL },
+    { NOTIFICATION_ITEM_DBUS_IFACE, "Menu", "o", FcitxNotificationItemGetMenu, NULL },
+    { NOTIFICATION_ITEM_DBUS_IFACE, "ToolTip", "(sa(iiay)ss)", FcitxNotificationItemGetToolTip, NULL },
+    { NOTIFICATION_ITEM_DBUS_IFACE, "XAyatanaLabel", "s", FcitxNotificationItemGetXAyatanaLabel, NULL },
+    { NOTIFICATION_ITEM_DBUS_IFACE, "XAyatanaLabelGuide", "s", FcitxNotificationItemGetXAyatanaLabelGuide, NULL },
+    { NOTIFICATION_ITEM_DBUS_IFACE, "XAyatanaOrderingIndex", "u", FcitxNotificationItemGetXAyatanaOrderingIndex, NULL },
+    { NULL, NULL, NULL, NULL, NULL }
+};
+
+DECLARE_ADDFUNCTIONS(NotificationItem)
+
+void* FcitxNotificationItemCreate(FcitxInstance* instance)
+{
+    FcitxNotificationItem* notificationitem = fcitx_utils_new(FcitxNotificationItem);
+    notificationitem->owner = instance;
+    DBusError err;
+    dbus_error_init(&err);
+    do {
+        DBusConnection *conn = FcitxDBusGetConnection(instance);
+        if (conn == NULL) {
+            FcitxLog(ERROR, "DBus Not initialized");
+            break;
+        }
+
+        notificationitem->conn = conn;
+
+        if (!dbus_connection_add_filter(notificationitem->conn, FcitxNotificationItemDBusFilter, notificationitem, NULL)) {
+            FcitxLog(ERROR, "No memory");
+            break;
+        }
+
+        DBusObjectPathVTable fcitxIPCVTable = {NULL, &FcitxNotificationItemEventHandler, NULL, NULL, NULL, NULL };
+        if (!dbus_connection_register_object_path(notificationitem->conn, NOTIFICATION_ITEM_DEFAULT_OBJ, &fcitxIPCVTable, notificationitem)) {
+            FcitxLog(ERROR, "No memory");
+            break;
+        }
+
+        if (!FcitxDBusMenuCreate(notificationitem)) {
+            FcitxLog(ERROR, "No memory");
+            break;
+        }
+
+        dbus_bus_add_match(notificationitem->conn,
+                           "type='signal',"
+                           "interface='" DBUS_INTERFACE_DBUS "',"
+                           "path='" DBUS_PATH_DBUS "',"
+                           "member='NameOwnerChanged',"
+                           "arg0='" NOTIFICATION_WATCHER_DBUS_ADDR "'",
+                           &err);
+        dbus_connection_flush(notificationitem->conn);
+        if (dbus_error_is_set(&err)) {
+            FcitxLog(ERROR, "Match Error (%s)", err.message);
+            break;
+        }
+
+        const char* notificationWatcher = NOTIFICATION_WATCHER_DBUS_ADDR;
+        DBusMessage* message = dbus_message_new_method_call(DBUS_SERVICE_DBUS, DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS, "NameHasOwner");
+        dbus_message_append_args(message, DBUS_TYPE_STRING, &notificationWatcher, DBUS_TYPE_INVALID);
+
+        DBusPendingCall* call = NULL;
+        dbus_bool_t reply = dbus_connection_send_with_reply(notificationitem->conn, message,
+                                                            &call,
+                                                            0);
+        if (reply == TRUE) {
+            dbus_pending_call_set_notify(call,
+                                         NotificationWatcherServiceExistCallback,
+                                         notificationitem,
+                                         NULL);
+        }
+        dbus_connection_flush(notificationitem->conn);
+        dbus_message_unref(message);
+
+        FcitxIMEventHook hk;
+        hk.arg = notificationitem;
+        hk.func = FcitxNotificationItemIMChanged;
+        FcitxInstanceRegisterIMChangedHook(instance, hk);
+        FcitxInstanceRegisterInputFocusHook(instance, hk);
+        FcitxInstanceRegisterInputUnFocusHook(instance, hk);
+
+        dbus_error_free(&err);
+
+        FcitxNotificationItemAddFunctions(instance);
+
+        return notificationitem;
+    } while(0);
+
+    dbus_error_free(&err);
+    FcitxNotificationItemDestroy(notificationitem);
+
+    return NULL;
+}
+
+void FcitxNotificationItemDestroy(void* arg)
+{
+    FcitxNotificationItem* notificationitem = (FcitxNotificationItem*) arg;
+    if (notificationitem->conn) {
+        dbus_connection_unregister_object_path(notificationitem->conn, NOTIFICATION_ITEM_DEFAULT_OBJ);
+        dbus_connection_unregister_object_path(notificationitem->conn, "/MenuBar");
+        dbus_connection_remove_filter(notificationitem->conn, FcitxNotificationItemDBusFilter, notificationitem);
+
+        dbus_bus_remove_match(notificationitem->conn,
+                           "type='signal',"
+                           "interface='" DBUS_INTERFACE_DBUS "',"
+                           "path='" DBUS_PATH_DBUS "',"
+                           "member='NameOwnerChanged',"
+                           "arg0='" NOTIFICATION_WATCHER_DBUS_ADDR "'",
+                           NULL);
+    }
+
+    free(notificationitem);
+}
+
+void FcitxNotificationItemRegister(FcitxNotificationItem* notificationitem)
+{
+    if (!notificationitem->serviceName) {
+        FcitxLog(ERROR, "This should not happen, please report bug.");
+        return;
+    }
+
+    DBusMessage* message = dbus_message_new_method_call(NOTIFICATION_WATCHER_DBUS_ADDR,
+                                                        NOTIFICATION_WATCHER_DBUS_OBJ,
+                                                        NOTIFICATION_WATCHER_DBUS_IFACE,
+                                                        "RegisterStatusNotifierItem");
+    dbus_message_append_args(message, DBUS_TYPE_STRING, &notificationitem->serviceName, DBUS_TYPE_INVALID);
+
+    DBusPendingCall* call = NULL;
+    dbus_bool_t reply = dbus_connection_send_with_reply(notificationitem->conn, message,
+                                                        &call,
+                                                        0);
+    if (reply == TRUE) {
+        dbus_pending_call_set_notify(call,
+                                     FcitxNotificationItemRegisterSuccess,
+                                     notificationitem,
+                                     NULL);
+    }
+}
+
+void FcitxNotificationItemRegisterSuccess(DBusPendingCall *call, void *data)
+{
+    FcitxNotificationItem* notificationitem = (FcitxNotificationItem*) data;
+    if (notificationitem->callback) {
+        notificationitem->callback(notificationitem->data, true);
+    }
+}
+
+void NotificationWatcherServiceExistCallback(DBusPendingCall *call, void *data)
+{
+    FcitxNotificationItem* notificationitem = (FcitxNotificationItem*) data;
+
+    DBusMessage* msg = dbus_pending_call_steal_reply(call);
+
+    if (msg) {
+        dbus_bool_t has;
+        DBusError error;
+        dbus_error_init(&error);
+        dbus_message_get_args(msg, &error, DBUS_TYPE_BOOLEAN, &has , DBUS_TYPE_INVALID);
+        FcitxNotificationItemSetAvailable(notificationitem, has);
+        dbus_message_unref(msg);
+        dbus_error_free(&error);
+    }
+
+    dbus_pending_call_cancel(call);
+    dbus_pending_call_unref(call);
+}
+
+DBusHandlerResult FcitxNotificationItemEventHandler (DBusConnection  *connection,
+                                            DBusMessage     *message,
+                                            void            *user_data)
+{
+    FcitxNotificationItem* notificationitem = user_data;
+    DBusHandlerResult result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    DBusMessage *reply = NULL;
+    boolean flush = false;
+    if (dbus_message_is_method_call(message, DBUS_INTERFACE_INTROSPECTABLE, "Introspect")) {
+        reply = dbus_message_new_method_return(message);
+
+        dbus_message_append_args(reply, DBUS_TYPE_STRING, &_notification_item, DBUS_TYPE_INVALID);
+    } else if (dbus_message_is_method_call(message, NOTIFICATION_ITEM_DBUS_IFACE, "Scroll")) {
+        reply = dbus_message_new_method_return(message);
+    } else if (dbus_message_is_method_call(message, NOTIFICATION_ITEM_DBUS_IFACE, "Activate")) {
+        FcitxInstanceChangeIMState(notificationitem->owner, FcitxInstanceGetCurrentIC(notificationitem->owner));
+        reply = dbus_message_new_method_return(message);
+    } else if (dbus_message_is_method_call(message, NOTIFICATION_ITEM_DBUS_IFACE, "SecondaryActivate")) {
+        reply = dbus_message_new_method_return(message);
+    } else if (dbus_message_is_method_call(message, DBUS_INTERFACE_PROPERTIES, "Get")) {
+        reply = FcitxDBusPropertyGet(notificationitem, propertTable, message);
+    } else if (dbus_message_is_method_call(message, DBUS_INTERFACE_PROPERTIES, "Set")) {
+        reply = FcitxDBusPropertySet(notificationitem, propertTable, message);
+    } else if (dbus_message_is_method_call(message, DBUS_INTERFACE_PROPERTIES, "GetAll")) {
+        reply = FcitxDBusPropertyGetAll(notificationitem, propertTable, message);
+    }
+
+    if (reply) {
+        dbus_connection_send(connection, reply, NULL);
+        dbus_message_unref(reply);
+        if (flush) {
+            dbus_connection_flush(connection);
+        }
+        result = DBUS_HANDLER_RESULT_HANDLED;
+    }
+    return result;
+}
+
+char* FcitxNotificationItemGetIconNameString(FcitxNotificationItem* notificationitem)
+{
+    char* iconName = NULL;
+    FcitxIM* im = FcitxInstanceGetCurrentIM(notificationitem->owner);
+    const char* icon = "";
+    if (im) {
+        if (strncmp(im->uniqueName, "fcitx-keyboard-",
+                    strlen("fcitx-keyboard-")) != 0) {
+            icon = im->strIconName;
+        } else {
+            return strdup("input-keyboard");
+        }
+    }
+    fcitx_utils_alloc_cat_str(iconName, (icon[0] == '\0' || icon[0] == '/') ?
+                              "" : "fcitx-", icon);
+    return iconName;
+}
+
+void FcitxNotificationItemGetId(void* arg, DBusMessageIter* iter)
+{
+    const char* id = "Fcitx";
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &id);
+}
+
+void FcitxNotificationItemGetCategory(void* arg, DBusMessageIter* iter)
+{
+    const char* category = "SystemServices";
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &category);
+}
+
+void FcitxNotificationItemGetStatus(void* arg, DBusMessageIter* iter)
+{
+    const char* status = "Active";
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &status);
+}
+
+void FcitxNotificationItemGetTitle(void* arg, DBusMessageIter* iter)
+{
+    const char* title = "Fcitx";
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &title);
+}
+
+void FcitxNotificationItemGetIconName(void* arg, DBusMessageIter* iter)
+{
+    FcitxNotificationItem* notificationitem = (FcitxNotificationItem*) arg;
+    FcitxInputContext* ic = FcitxInstanceGetCurrentIC(notificationitem->owner);
+    if (ic == NULL) {
+        const char* iconName = "input-keyboard";
+        dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &iconName);
+    } else {
+        char* iconName = FcitxNotificationItemGetIconNameString(notificationitem);
+        dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &iconName);
+        free(iconName);
+    }
+}
+
+void FcitxNotificationItemGetAttentionIconName(void* arg, DBusMessageIter* iter)
+{
+    const char* iconName = "";
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &iconName);
+}
+
+void FcitxNotificationItemGetIconThemePath(void* arg, DBusMessageIter* iter)
+{
+    const char* iconThemePath = "";
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &iconThemePath);
+}
+
+void FcitxNotificationItemGetMenu(void* arg, DBusMessageIter* iter)
+{
+    const char* menu = "/MenuBar";
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &menu);
+}
+
+void FcitxNotificationItemGetToolTip(void* arg, DBusMessageIter* iter)
+{
+    FcitxNotificationItem* notificationitem = (FcitxNotificationItem*) arg;
+    DBusMessageIter sub, ssub;
+    char* iconNameToFree = NULL, *iconName, *title, *content;
+    dbus_message_iter_open_container(iter, DBUS_TYPE_STRUCT, 0, &sub);
+    FcitxInputContext* ic = FcitxInstanceGetCurrentIC(notificationitem->owner);
+    if (ic == NULL) {
+        iconName = "input-keyboard";
+        title = _("No input window");
+        content = "";
+    } else {
+        iconName = FcitxNotificationItemGetIconNameString(notificationitem);
+        iconNameToFree = iconName;
+        FcitxIM* im = FcitxInstanceGetCurrentIM(notificationitem->owner);
+        title = im ? im->strName : _("Disabled");
+        content = im ? "" : _("Input Method Disabled");
+    }
+    dbus_message_iter_append_basic(&sub, DBUS_TYPE_STRING, &iconName);
+    dbus_message_iter_open_container(&sub, DBUS_TYPE_ARRAY, "(iiay)", &ssub);
+    dbus_message_iter_close_container(&sub, &ssub);
+    dbus_message_iter_append_basic(&sub, DBUS_TYPE_STRING, &title);
+    dbus_message_iter_append_basic(&sub, DBUS_TYPE_STRING, &content);
+    dbus_message_iter_close_container(iter, &sub);
+
+    fcitx_utils_free(iconNameToFree);
+}
+
+const char* FcitxNotificationItemGetLabel(FcitxNotificationItem* notificationitem)
+{
+    const char* label = "";
+#if 0
+    FcitxInputContext* ic = FcitxInstanceGetCurrentIC(notificationitem->owner);
+    if (ic) {
+        FcitxIM* im = FcitxInstanceGetCurrentIM(notificationitem->owner);
+        if (im) {
+            label = im->strName;
+        }
+    }
+#endif
+    return label;
+}
+
+void FcitxNotificationItemGetXAyatanaLabel(void* arg, DBusMessageIter* iter)
+{
+    FcitxNotificationItem* notificationitem = (FcitxNotificationItem*) arg;
+    const char* label = FcitxNotificationItemGetLabel(notificationitem);
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &label);
+}
+
+void FcitxNotificationItemGetXAyatanaLabelGuide(void* arg, DBusMessageIter* iter)
+{
+    const char* label = "";
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &label);
+}
+
+void FcitxNotificationItemGetXAyatanaOrderingIndex(void* arg, DBusMessageIter* iter)
+{
+    uint32_t index = 0;
+    dbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &index);
+}
+
+void FcitxNotificationItemIMChanged(void* arg)
+{
+    FcitxNotificationItem* notificationitem = (FcitxNotificationItem*) arg;
+
+#define SEND_SIGNAL(NAME) do { \
+    DBusMessage* msg = dbus_message_new_signal(NOTIFICATION_ITEM_DEFAULT_OBJ, \
+                                               NOTIFICATION_ITEM_DBUS_IFACE, \
+                                               NAME); \
+    if (msg) { \
+        dbus_connection_send(notificationitem->conn, msg, NULL); \
+    } \
+    } while(0)
+
+    SEND_SIGNAL("NewIcon");
+    SEND_SIGNAL("NewToolTip");
+#if 0
+    do {
+        DBusMessage* msg = dbus_message_new_signal(NOTIFICATION_ITEM_DEFAULT_OBJ,
+                                                   NOTIFICATION_ITEM_DBUS_IFACE,
+                                                   "XAyatanaNewLabel");
+        if (msg) {
+            const char* label = FcitxNotificationItemGetLabel(notificationitem);
+            const char* guide = "XXXXXXXXXXXXXXX";
+            dbus_message_append_args(msg,
+                                     DBUS_TYPE_STRING, &label,
+                                     DBUS_TYPE_STRING, &guide,
+                                     DBUS_TYPE_INVALID);
+            dbus_connection_send(notificationitem->conn, msg, NULL);
+        }
+    } while(0);
+#endif
+}
+
+boolean FcitxNotificationItemEnable(FcitxNotificationItem* notificationitem, FcitxNotificationItemAvailableCallback callback, void* data)
+{
+    if (!callback || notificationitem->callback)
+        return false;
+    if (notificationitem->serviceName) {
+        FcitxLog(ERROR, "This should not happen, please report bug.");
+        return false;
+    }
+    notificationitem->callback = callback;
+    notificationitem->data = data;
+    asprintf(&notificationitem->serviceName, "org.kde.StatusNotifierItem-%u-%d", getpid(), ++notificationitem->index);
+
+    /* once we have name, request it first */
+    DBusError err;
+    dbus_error_init(&err);
+    dbus_bus_request_name(notificationitem->conn, notificationitem->serviceName,
+                                    DBUS_NAME_FLAG_DO_NOT_QUEUE,
+                                    &err);
+    if (dbus_error_is_set(&err)) {
+        FcitxLog(WARNING, "NotificationItem Name Error (%s)", err.message);
+    }
+    dbus_error_free(&err);
+
+    if (notificationitem->available) {
+        if (notificationitem->callback) {
+            FcitxNotificationItemRegister(notificationitem);
+        }
+    }
+    return true;
+}
+
+void FcitxNotificationItemDisable(FcitxNotificationItem* notificationitem)
+{
+    notificationitem->callback = NULL;
+    notificationitem->data = NULL;
+
+    if (notificationitem->serviceName) {
+        dbus_bus_release_name(notificationitem->conn, notificationitem->serviceName, NULL);
+        free(notificationitem->serviceName);
+        notificationitem->serviceName = NULL;
+    }
+}
+
+DBusHandlerResult FcitxNotificationItemDBusFilter(DBusConnection* connection, DBusMessage* msg, void* user_data)
+{
+    FcitxNotificationItem* notificationitem = (FcitxNotificationItem*) user_data;
+    if (dbus_message_is_signal(msg, DBUS_INTERFACE_DBUS, "NameOwnerChanged")) {
+        const char* service, *oldowner, *newowner;
+        DBusError error;
+        dbus_error_init(&error);
+        do {
+            if (!dbus_message_get_args(msg, &error,
+                                       DBUS_TYPE_STRING, &service ,
+                                       DBUS_TYPE_STRING, &oldowner ,
+                                       DBUS_TYPE_STRING, &newowner ,
+                                       DBUS_TYPE_INVALID)) {
+                break;
+            }
+            /* old die and no new one */
+            if (strcmp(service, NOTIFICATION_WATCHER_DBUS_ADDR) != 0) {
+                break;
+            }
+
+            FcitxNotificationItemSetAvailable (notificationitem, strlen(newowner) > 0);
+            return DBUS_HANDLER_RESULT_HANDLED;
+        } while(0);
+        dbus_error_free(&error);
+    }
+
+    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+void FcitxNotificationItemSetAvailable(FcitxNotificationItem* notificationitem, boolean available)
+{
+    if (notificationitem->available != available) {
+        notificationitem->available = available;
+        if (available) {
+            if (notificationitem->callback) {
+                FcitxNotificationItemRegister(notificationitem);
+            }
+        } else {
+            if (notificationitem->callback) {
+                if (notificationitem->callback) {
+                    notificationitem->callback(notificationitem->data, false);
+                }
+            }
+        }
+    }
+}
+
+#include "fcitx-notificationitem-addfunctions.h"
diff --git a/src/module/notificationitem/notificationitem.h b/src/module/notificationitem/notificationitem.h
new file mode 100644
index 0000000..b7b8f3a
--- /dev/null
+++ b/src/module/notificationitem/notificationitem.h
@@ -0,0 +1,28 @@
+/***************************************************************************
+ *   Copyright (C) 2013~2013 by CSSlayer                                   *
+ *   wengxt@gmail.com                                                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef _FCITX_MODULE_NOTIFICATIONITEM_H
+#define _FCITX_MODULE_NOTIFICATIONITEM_H
+
+#include <fcitx-utils/utils.h>
+
+typedef void (*FcitxNotificationItemAvailableCallback)(void* arg, boolean enable);
+
+#endif // _FCITX_MODULE_NOTIFICATIONITEM_H
diff --git a/src/module/notificationitem/notificationitem_p.h b/src/module/notificationitem/notificationitem_p.h
new file mode 100644
index 0000000..fab73fb
--- /dev/null
+++ b/src/module/notificationitem/notificationitem_p.h
@@ -0,0 +1,41 @@
+/***************************************************************************
+ *   Copyright (C) 2013~2013 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef NOTIFICATIONITEM_P_H
+#define NOTIFICATIONITEM_P_H
+
+#include <dbus/dbus.h>
+#include "fcitx/instance.h"
+#include "notificationitem.h"
+
+typedef struct _FcitxNotificationItem {
+    FcitxInstance* owner;
+    DBusConnection* conn;
+    FcitxNotificationItemAvailableCallback callback;
+    void* data;
+    boolean available;
+    int index;
+    char* serviceName;
+    uint32_t revision;
+    int pendingActionId;
+} FcitxNotificationItem;
+
+boolean FcitxDBusMenuCreate(FcitxNotificationItem* notificationitem);
+
+#endif // NOTIFICATIONITEM_P_H
diff --git a/src/module/quickphrase/quickphrase.c b/src/module/quickphrase/quickphrase.c
index a28e829..fcf719b 100644
--- a/src/module/quickphrase/quickphrase.c
+++ b/src/module/quickphrase/quickphrase.c
@@ -525,7 +525,6 @@ QuickPhraseDoInput(void* arg, FcitxKeySym sym, int state)
     } else {
         return IRV_TO_PROCESS;
     }
-
     FcitxCandidateWordSetType(cand_word, MSG_CANDIATE_CURSOR);
     return IRV_FLAG_UPDATE_INPUT_WINDOW;
 }
@@ -580,6 +579,7 @@ INPUT_RETURN_VALUE QuickPhraseGetCandWords(QuickPhraseState* qpstate)
     FcitxCandidateWordSetPageSize(candList, config->iMaxCandWord);
     FcitxCandidateWordSetChooseAndModifier(
         candList, DIGIT_STR_CHOOSE, cmodtable[qpstate->config.chooseModifier]);
+    FcitxCandidateWordSetOverrideDefaultHighlight(candList, false);
 
     pKey = &searchKey;
 
@@ -629,6 +629,9 @@ INPUT_RETURN_VALUE QuickPhraseGetCandWords(QuickPhraseState* qpstate)
     } while(0);
 
     QuickPhraseGetSpellHint(qpstate);
+    FcitxCandidateWord *cand_word_p = FcitxCandidateWordGetFirst(candList);
+    if (cand_word_p)
+        FcitxCandidateWordSetType(cand_word_p, MSG_CANDIATE_CURSOR);
     return IRV_DISPLAY_MESSAGE;
 }
 
diff --git a/src/module/xkb/xkb.c b/src/module/xkb/xkb.c
index 82f862d..d6bf1cb 100644
--- a/src/module/xkb/xkb.c
+++ b/src/module/xkb/xkb.c
@@ -75,7 +75,7 @@ static char* FcitxXkbGetCurrentOption(FcitxXkb* xkb);
 #endif
 static boolean
 FcitxXkbSetLayoutByName(FcitxXkb *xkb,
-                        const char *layout, const char *variant);
+                        const char *layout, const char *variant, boolean toDefault);
 static void
 FcitxXkbRetrieveCloseGroup(FcitxXkb *xkb);
 static boolean FcitxXkbSetLayout  (FcitxXkb* xkb,
@@ -176,37 +176,50 @@ static char* FcitxXkbFindXkbRulesFile(FcitxXkb* xkb)
         } else {
             int count = 0, i = 0;
             const char* base = XLIBDIR;
+            char *parent_to_free = NULL;
             while (base[i]) {
                 if (base[i] == '/')
                     count++;
                 i++;
             }
 
+            /**
+             * guess X11 data base directory.
+             **/
             if (count >= 3) {
                 // .../usr/lib/X11 -> /usr/share/X11/xkb vs
                 // .../usr/X11/lib -> /usr/X11/share/X11/xkb
                 const char* delta = StringEndsWith(base, "X11") ?
                     "/../../share/X11" : "/../share/X11";
-                char *tmppath;
-                fcitx_utils_alloc_cat_str(tmppath, base, delta,
-                                          "/xkb/rules/", rulesName, ".xml");
-                if(fcitx_utils_isreg(tmppath)) {
-                    rulesFile = realpath(tmppath, NULL);
-                    free(tmppath);
-                } else {
-                    fcitx_utils_alloc_cat_str(tmppath, base, "/X11/xkb/rules/",
-                                              rulesName, ".xml");
-                    if(fcitx_utils_isreg(tmppath)) {
-                        rulesFile = realpath(tmppath, NULL);
-                        free(tmppath);
+                fcitx_utils_alloc_cat_str(parent_to_free, base, delta);
+                if(!fcitx_utils_isdir(parent_to_free)) {
+                    // fallback to ${base}/X11
+                    fcitx_utils_set_cat_str(parent_to_free, base, "/X11");
+                    if(!fcitx_utils_isdir(parent_to_free)) {
+                        free(parent_to_free);
+                        parent_to_free = NULL;
                     }
                 }
             }
-            if(!rulesFile) {
-                fcitx_utils_alloc_cat_str(rulesFile,
-                                          "/usr/share/X11/xkb/rules/",
-                                          rulesName, ".xml");
+            const char *parent_path;
+            if (parent_to_free) {
+                /**
+                 * Found a existing dir, simplify it.
+                 * Using realpath() on rules files' name can change the base
+                 * name of the file (due to symlink), so it is only safe
+                 * to do it for directory's name. T-T..
+                 **/
+                char *tmp = realpath(parent_to_free, NULL);
+                parent_path = tmp;
+                free(parent_to_free);
+                parent_to_free = tmp;
+            } else {
+                // last fallback for known rules name.
+                parent_path = "/usr/share/X11";
             }
+            fcitx_utils_alloc_cat_str(rulesFile, parent_path,
+                                      "/xkb/rules/", rulesName, ".xml");
+            fcitx_utils_free(parent_to_free);
         }
         free(rulesName);
     } else {
@@ -219,7 +232,7 @@ static void
 FcitxXkbInitDefaultLayout(FcitxXkb* xkb)
 {
     Display* dpy = xkb->dpy;
-        XkbRF_VarDefsRec vd;
+    XkbRF_VarDefsRec vd;
 
     utarray_clear(xkb->defaultLayouts);
     utarray_clear(xkb->defaultModels);
@@ -291,8 +304,8 @@ FcitxXkbSetRules(FcitxXkb* xkb, const char *rules_file, const char *model,
     memset(&rnames, 0, sizeof(XkbComponentNamesRec));
     rdefs.model = model ? strdup(model) : NULL;
     rdefs.layout = all_layouts ? strdup(all_layouts) : NULL;
-    rdefs.variant = all_variants ? strdup(all_variants) : NULL;
-    rdefs.options = all_options ? strdup(all_options) : NULL;
+    rdefs.variant = all_variants && all_variants[0] ? strdup(all_variants) : NULL;
+    rdefs.options = all_options && all_options[0] ? strdup(all_options) : NULL;
     XkbRF_GetComponents(rules, &rdefs, &rnames);
     xkbDesc = XkbGetKeyboardByName(dpy, XkbUseCoreKbd, &rnames,
                                    XkbGBN_AllComponentsMask,
@@ -496,7 +509,7 @@ FcitxXkbGetCurrentGroup(FcitxXkb* xkb)
 }
 
 static void FcitxXkbAddNewLayout(FcitxXkb* xkb, const char* layoutString,
-                                 const char* variantString)
+                                 const char* variantString, boolean toDefault, int index)
 {
     if (!layoutString)
         return;
@@ -506,41 +519,59 @@ static void FcitxXkbAddNewLayout(FcitxXkb* xkb, const char* layoutString,
         const char* dummy = "";
         utarray_push_back(xkb->defaultVariants, &dummy);
     }
-    while (utarray_len(xkb->defaultVariants) >= 4) {
-        utarray_pop_back(xkb->defaultVariants);
-        utarray_pop_back(xkb->defaultLayouts);
-    }
-    utarray_push_back(xkb->defaultLayouts, &layoutString);
-    if (variantString)
-        utarray_push_back(xkb->defaultVariants, &variantString);
-    else {
-        const char* dummy = "";
-        utarray_push_back(xkb->defaultVariants, &dummy);
+
+    if (toDefault) {
+        if (index == 0) {
+            return;
+        }
+        if (index > 0) {
+            utarray_remove_quick_full(xkb->defaultLayouts, index);
+            utarray_remove_quick_full(xkb->defaultVariants, index);
+        }
+        utarray_push_front(xkb->defaultLayouts, &layoutString);
+        if (variantString) {
+            utarray_push_front(xkb->defaultVariants, &variantString);
+        } else {
+            const char *dummy = "";
+            utarray_push_front(xkb->defaultVariants, &dummy);
+        }
+    } else {
+        while (utarray_len(xkb->defaultVariants) >= 4) {
+            utarray_pop_back(xkb->defaultVariants);
+            utarray_pop_back(xkb->defaultLayouts);
+        }
+        utarray_push_back(xkb->defaultLayouts, &layoutString);
+        if (variantString) {
+            utarray_push_back(xkb->defaultVariants, &variantString);
+        } else {
+            const char *dummy = "";
+            utarray_push_back(xkb->defaultVariants, &dummy);
+        }
     }
     FcitxXkbSetLayout(xkb, NULL, NULL, NULL);
 }
 
 static int
-FcitxXkbFindOrAddLayout(FcitxXkb *xkb, const char *layout, const char *variant)
+FcitxXkbFindOrAddLayout(FcitxXkb *xkb, const char *layout, const char *variant, boolean toDefault)
 {
     int index;
     if (layout == NULL)
         return -1;
     index = FcitxXkbFindLayoutIndex(xkb, layout, variant);
-    if (index >= 0)
-        return index;
     if (!xkb->config.bOverrideSystemXKBSettings)
-        return -1;
-    FcitxXkbAddNewLayout(xkb, layout, variant);
+        return index;
+    if (!(index < 0 || (index > 0 && toDefault)))
+        return index;
+    FcitxXkbAddNewLayout(xkb, layout, variant, toDefault, index);
     FcitxXkbInitDefaultLayout(xkb);
     return FcitxXkbFindLayoutIndex(xkb, layout, variant);
 }
 
 static boolean
-FcitxXkbSetLayoutByName(FcitxXkb *xkb, const char *layout, const char *variant)
+FcitxXkbSetLayoutByName(FcitxXkb *xkb, const char *layout, const char *variant, boolean toDefault)
 {
     int index;
-    index = FcitxXkbFindOrAddLayout(xkb, layout, variant);
+    index = FcitxXkbFindOrAddLayout(xkb, layout, variant, toDefault);
     if (index < 0) {
         return false;
     }
@@ -554,9 +585,9 @@ FcitxXkbRetrieveCloseGroup(FcitxXkb *xkb)
     LayoutOverride* item = NULL;
     HASH_FIND_STR(xkb->layoutOverride, "default", item);
     if (item)
-        FcitxXkbSetLayoutByName(xkb, item->layout, item->variant);
+        FcitxXkbSetLayoutByName(xkb, item->layout, item->variant, true);
     else
-        FcitxXkbSetLayoutByName(xkb, xkb->closeLayout, xkb->closeVariant);
+        FcitxXkbSetLayoutByName(xkb, xkb->closeLayout, xkb->closeVariant, true);
 }
 
 static void FcitxXkbIMKeyboardLayoutChanged(void* arg, const void* value)
@@ -598,7 +629,7 @@ static void FcitxXkbIMKeyboardLayoutChanged(void* arg, const void* value)
                 variantString = NULL;
             }
         }
-        if (!FcitxXkbSetLayoutByName(xkb, layoutString, variantString))
+        if (!FcitxXkbSetLayoutByName(xkb, layoutString, variantString, false))
             FcitxXkbRetrieveCloseGroup(xkb);
         if (s) {
             fcitx_utils_free_string_list(s);
@@ -642,6 +673,7 @@ FcitxXkbSaveCloseGroup(FcitxXkb *xkb)
     fcitx_utils_free(xkb->closeVariant);
     xkb->closeLayout = tmplayout;
     xkb->closeVariant = tmpvariant;
+    FcitxXkbRetrieveCloseGroup(xkb);
 }
 
 static void
@@ -716,6 +748,13 @@ static void* FcitxXkbCreate(FcitxInstance* instance)
     return NULL;
 }
 
+static void FcitxXkbScheduleRefresh(void* arg) {
+    FcitxXkb* xkb = (FcitxXkb*) arg;
+    FcitxUIUpdateInputWindow(xkb->owner);
+    FcitxXkbInitDefaultLayout(xkb);
+    FcitxXkbApplyCustomScript(xkb);
+}
+
 static boolean FcitxXkbEventHandler(void* arg, XEvent* event)
 {
     FcitxXkb* xkb = (FcitxXkb*) arg;
@@ -739,9 +778,8 @@ static boolean FcitxXkbEventHandler(void* arg, XEvent* event)
         ) {
             xkb->lastSerial = xkbEvent->new_kbd.serial;
             XSync(xkb->dpy, False);
-            FcitxUIUpdateInputWindow(xkb->owner);
-            FcitxXkbInitDefaultLayout(xkb);
-            FcitxXkbApplyCustomScript(xkb);
+            FcitxInstanceRemoveTimeoutByFunc(xkb->owner, FcitxXkbScheduleRefresh);
+            FcitxInstanceAddTimeout(xkb->owner, 10, FcitxXkbScheduleRefresh, xkb);
         }
         return true;
     }
diff --git a/src/ui/classic/TrayWindow.c b/src/ui/classic/TrayWindow.c
index 59152f2..5db9980 100644
--- a/src/ui/classic/TrayWindow.c
+++ b/src/ui/classic/TrayWindow.c
@@ -103,7 +103,7 @@ TrayWindow* CreateTrayWindow(FcitxClassicUI *classicui)
     TrayWindow *trayWindow = fcitx_utils_malloc0(sizeof(TrayWindow));
     trayWindow->owner = classicui;
     FcitxX11AddXEventHandler(classicui->owner, TrayEventHandler, trayWindow);
-    InitTrayWindow(trayWindow);
+    /* We used to init trayWindow here, but now we should delay it */
     return trayWindow;
 }
 
diff --git a/src/ui/classic/TrayWindow.h b/src/ui/classic/TrayWindow.h
index 6af45e7..cf951f5 100644
--- a/src/ui/classic/TrayWindow.h
+++ b/src/ui/classic/TrayWindow.h
@@ -53,6 +53,7 @@ typedef struct _TrayWindow {
 TrayWindow* CreateTrayWindow(struct _FcitxClassicUI *classicui);
 void DrawTrayWindow(TrayWindow* trayWindow);
 void RedrawTrayWindow(TrayWindow* trayWindow);
+/* these two function can be called more than once */
 void ReleaseTrayWindow(TrayWindow* trayWindow);
 void InitTrayWindow(TrayWindow *trayWindow);
 #endif
diff --git a/src/ui/classic/classicui.c b/src/ui/classic/classicui.c
index a1522d5..313c127 100644
--- a/src/ui/classic/classicui.c
+++ b/src/ui/classic/classicui.c
@@ -45,6 +45,7 @@
 #include "MessageWindow.h"
 #include "fcitx/hook.h"
 #include "fcitx-utils/utils.h"
+#include "module/notificationitem/fcitx-notificationitem.h"
 
 struct _FcitxSkin;
 static boolean MainMenuAction(FcitxUIMenu* menu, int index);
@@ -68,6 +69,9 @@ static void ClassicUIInputReset(void *arg);
 static void ReloadConfigClassicUI(void *arg);
 static void ClassicUISuspend(void *arg);
 static void ClassicUIResume(void *arg);
+static void ClassicUIDelayedInitTray(void* arg);
+static void ClassicUIDelayedShowTray(void* arg);
+static void ClassicUINotificationItemAvailable(void* arg, boolean avaiable);
 
 static FcitxConfigFileDesc* GetClassicUIDesc();
 static void ClassicUIMainWindowSizeHint(void *arg, int* x, int* y,
@@ -157,9 +161,40 @@ void* ClassicUICreate(FcitxInstance* instance)
     DisplaySkin(classicui, classicui->skinType);
 
     FcitxClassicUIAddFunctions(instance);
+
+    FcitxInstanceAddTimeout(instance, 0, ClassicUIDelayedInitTray, classicui);
+
     return classicui;
 }
 
+void ClassicUIDelayedInitTray(void* arg) {
+    FcitxClassicUI* classicui = (FcitxClassicUI*) arg;
+    // FcitxLog(INFO, "yeah we delayed!");
+    if (!classicui->bUseTrayIcon)
+        return;
+    /*
+     * if this return false, something wrong happened and callback
+     * will never be called, show tray directly
+     */
+    if (FcitxNotificationItemEnable(classicui->owner, ClassicUINotificationItemAvailable, classicui)) {
+        if (!classicui->trayTimeout)
+            classicui->trayTimeout = FcitxInstanceAddTimeout(classicui->owner, 100, ClassicUIDelayedShowTray, classicui);
+    } else {
+        ReleaseTrayWindow(classicui->trayWindow);
+        InitTrayWindow(classicui->trayWindow);
+    }
+}
+
+void ClassicUIDelayedShowTray(void* arg)
+{
+    FcitxClassicUI* classicui = (FcitxClassicUI*) arg;
+    classicui->trayTimeout = 0;
+    if (!classicui->bUseTrayIcon)
+        return;
+    ReleaseTrayWindow(classicui->trayWindow);
+    InitTrayWindow(classicui->trayWindow);
+}
+
 void ClassicUISetWindowProperty(FcitxClassicUI* classicui, Window window, FcitxXWindowType type, char *windowTitle)
 {
     FcitxX11SetWindowProp(classicui->owner, &window, &type, windowTitle);
@@ -260,13 +295,31 @@ void ClassicUISuspend(void* arg)
     CloseInputWindowInternal(classicui->inputWindow);
     CloseMainWindow(classicui->mainWindow);
     ReleaseTrayWindow(classicui->trayWindow);
+    /* always call this function will not do anything harm */
+    FcitxNotificationItemDisable(classicui->owner);
 }
 
 void ClassicUIResume(void* arg)
 {
     FcitxClassicUI* classicui = (FcitxClassicUI*) arg;
     classicui->isSuspend = false;
-    InitTrayWindow(classicui->trayWindow);
+    ClassicUIDelayedInitTray(classicui);
+}
+
+void ClassicUINotificationItemAvailable(void* arg, boolean avaiable) {
+    FcitxClassicUI* classicui = (FcitxClassicUI*) arg;
+    /* ClassicUISuspend has already done all clean up */
+    if (classicui->isSuspend)
+        return;
+    if (!avaiable) {
+        ReleaseTrayWindow(classicui->trayWindow);
+        InitTrayWindow(classicui->trayWindow);
+    } else {
+        if (classicui->trayTimeout) {
+            FcitxInstanceRemoveTimeoutById(classicui->owner, classicui->trayTimeout);
+        }
+        ReleaseTrayWindow(classicui->trayWindow);
+    }
 }
 
 void ActivateWindow(Display *dpy, int iScreen, Window window)
@@ -397,7 +450,7 @@ static void UpdateMainMenu(FcitxUIMenu* menu)
             status = (FcitxUIStatus*) utarray_next(uistats, status)
         ) {
         FcitxClassicUIStatus* privstat =  GetPrivateStatus(status);
-        if (privstat == NULL || !status->visible || privstat->avail )
+        if (privstat == NULL || !status->visible)
             continue;
 
         flag = true;
@@ -411,7 +464,7 @@ static void UpdateMainMenu(FcitxUIMenu* menu)
             compstatus = (FcitxUIComplexStatus*) utarray_next(uicompstats, compstatus)
         ) {
         FcitxClassicUIStatus* privstat =  GetPrivateStatus(compstatus);
-        if (privstat == NULL || !compstatus->visible || privstat->avail)
+        if (privstat == NULL || !compstatus->visible)
             continue;
         if (FcitxUIGetMenuByStatusName(instance, compstatus->name))
             continue;
@@ -441,8 +494,6 @@ static void UpdateMainMenu(FcitxUIMenu* menu)
             if (compStatus) {
                 if (!compStatus->visible)
                     continue;
-                if (GetPrivateStatus(compStatus)->avail)
-                    continue;
             }
         }
 
diff --git a/src/ui/classic/classicui.h b/src/ui/classic/classicui.h
index efa8674..cc9699e 100644
--- a/src/ui/classic/classicui.h
+++ b/src/ui/classic/classicui.h
@@ -84,6 +84,7 @@ typedef struct _FcitxClassicUI {
     boolean isfallback;
 
     int dpi;
+    uint64_t trayTimeout;
 } FcitxClassicUI;
 
 void GetScreenSize(FcitxClassicUI* classicui, int* width, int* height);
diff --git a/src/ui/classic/skin.c b/src/ui/classic/skin.c
index 8e0bb5c..3679542 100644
--- a/src/ui/classic/skin.c
+++ b/src/ui/classic/skin.c
@@ -674,7 +674,9 @@ void DrawInputBar(FcitxSkin* sc, InputWindow* inputWindow, boolean vertical, int
     int currentX = 0;
     int offsetY;
     if (sc->skinFont.respectDPI)
-        offsetY = sc->skinInputBar.marginTop + sc->skinInputBar.iInputPos + fontHeight + (FcitxMessagesGetMessageCount(msgdown) ? sc->skinInputBar.iOutputPos : 0);
+        offsetY = sc->skinInputBar.marginTop
+                 + (FcitxMessagesGetMessageCount(msgup) ? (sc->skinInputBar.iInputPos + fontHeight) : 0)
+                 + (FcitxMessagesGetMessageCount(msgdown) ? sc->skinInputBar.iOutputPos : 0);
     else
         offsetY = sc->skinInputBar.marginTop + sc->skinInputBar.iOutputPos - fontHeight;
     for (i = 0; i < FcitxMessagesGetMessageCount(msgdown) ; i++) {
@@ -753,14 +755,16 @@ void DrawInputBar(FcitxSkin* sc, InputWindow* inputWindow, boolean vertical, int
 
     cairo_set_operator(c, CAIRO_OPERATOR_OVER);
 
-
-    if (FcitxInputStateGetShowCursor(input)) {
+    FcitxCandidateWordList* candList = FcitxInputStateGetCandidateList(input);
+    if (FcitxCandidateWordHasPrev(candList)
+        || FcitxCandidateWordHasNext(candList)
+    ) {
         //画向前向后箭头
         if (prev && next) {
             cairo_set_source_surface(inputWindow->c_back, prev->image,
                                      newWidth - sc->skinInputBar.iBackArrowX ,
                                      sc->skinInputBar.iBackArrowY);
-            if (FcitxCandidateWordHasPrev(FcitxInputStateGetCandidateList(input)))
+            if (FcitxCandidateWordHasPrev(candList))
                 cairo_paint(inputWindow->c_back);
             else
                 cairo_paint_with_alpha(inputWindow->c_back, 0.5);
@@ -769,7 +773,7 @@ void DrawInputBar(FcitxSkin* sc, InputWindow* inputWindow, boolean vertical, int
             cairo_set_source_surface(inputWindow->c_back, next->image,
                                      newWidth - sc->skinInputBar.iForwardArrowX ,
                                      sc->skinInputBar.iForwardArrowY);
-            if (FcitxCandidateWordHasNext(FcitxInputStateGetCandidateList(input)))
+            if (FcitxCandidateWordHasNext(candList))
                 cairo_paint(inputWindow->c_back);
             else
                 cairo_paint_with_alpha(inputWindow->c_back, 0.5);
@@ -799,7 +803,7 @@ void DrawInputBar(FcitxSkin* sc, InputWindow* inputWindow, boolean vertical, int
     }
 
     //画光标
-    if (FcitxInputStateGetShowCursor(input)) {
+    if (FcitxMessagesGetMessageCount(msgup) && FcitxInputStateGetShowCursor(input)) {
         cairo_move_to(inputWindow->c_cursor, cursor_pos, cursorY1);
         cairo_line_to(inputWindow->c_cursor, cursor_pos, cursorY2);
         cairo_stroke(inputWindow->c_cursor);
diff --git a/src/ui/kimpanel/kimpanel.c b/src/ui/kimpanel/kimpanel.c
index f3e1857..20d69be 100644
--- a/src/ui/kimpanel/kimpanel.c
+++ b/src/ui/kimpanel/kimpanel.c
@@ -45,69 +45,69 @@
 #define GetMenuItem(m, i) ((FcitxMenuItem*) utarray_eltptr(&(m)->shell, (i)))
 
 const char * kimpanel_introspection_xml =
-    "<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\"\n"
-    "\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n"
-    "<node name=\"" FCITX_KIMPANEL_PATH "\">\n"
-    "  <interface name=\"org.freedesktop.DBus.Introspectable\">\n"
-    "    <method name=\"Introspect\">\n"
-    "      <arg name=\"data\" direction=\"out\" type=\"s\"/>\n"
-    "    </method>\n"
-    "  </interface>\n"
-    "  <interface name=\"" FCITX_KIMPANEL_INTERFACE "\">\n"
-    "    <signal name=\"ExecDialog\">\n"
-    "      <arg name=\"prop\" direction=\"in\" type=\"s\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"ExecMenu\">\n"
-    "      <arg name=\"prop\" direction=\"in\" type=\"a\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"RegisterProperties\">\n"
-    "      <arg name=\"prop\" direction=\"in\" type=\"a\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"UpdateProperty\">\n"
-    "      <arg name=\"prop\" direction=\"in\" type=\"s\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"RemoveProperty\">\n"
-    "      <arg name=\"prop\" direction=\"in\" type=\"s\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"ShowAux\">\n"
-    "      <arg name=\"toshow\" direction=\"in\" type=\"b\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"ShowPreedit\">\n"
-    "      <arg name=\"toshow\" direction=\"in\" type=\"b\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"ShowLookupTable\">\n"
-    "      <arg name=\"toshow\" direction=\"in\" type=\"b\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"UpdateLookupTable\">\n"
-    "      <arg name=\"label\" direction=\"in\" type=\"a\"/>\n"
-    "      <arg name=\"text\" direction=\"in\" type=\"a\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"UpdateLookupTableCursor\">\n"
-    "      <arg name=\"cursor\" direction=\"in\" type=\"i\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"UpdatePreeditCaret\">\n"
-    "      <arg name=\"position\" direction=\"in\" type=\"i\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"UpdatePreeditText\">\n"
-    "      <arg name=\"text\" direction=\"in\" type=\"s\"/>\n"
-    "      <arg name=\"attr\" direction=\"in\" type=\"s\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"UpdateAux\">\n"
-    "      <arg name=\"text\" direction=\"in\" type=\"s\"/>\n"
-    "      <arg name=\"attr\" direction=\"in\" type=\"s\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"UpdateSpotLocation\">\n"
-    "      <arg name=\"x\" direction=\"in\" type=\"i\"/>\n"
-    "      <arg name=\"y\" direction=\"in\" type=\"i\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"UpdateScreen\">\n"
-    "      <arg name=\"screen\" direction=\"in\" type=\"i\"/>\n"
-    "    </signal>\n"
-    "    <signal name=\"Enable\">\n"
-    "      <arg name=\"toenable\" direction=\"in\" type=\"b\"/>\n"
-    "    </signal>\n"
-    "  </interface>\n"
-    "</node>\n";
+    "<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" "
+    "\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">"
+    "<node name=\"" FCITX_KIMPANEL_PATH "\">"
+    "<interface name=\"org.freedesktop.DBus.Introspectable\">"
+    "<method name=\"Introspect\">"
+    "<arg name=\"data\" direction=\"out\" type=\"s\"/>"
+    "</method>"
+    "</interface>"
+    "<interface name=\"" FCITX_KIMPANEL_INTERFACE "\">"
+    "<signal name=\"ExecDialog\">"
+    "<arg name=\"prop\" direction=\"in\" type=\"s\"/>"
+    "</signal>"
+    "<signal name=\"ExecMenu\">"
+    "<arg name=\"prop\" direction=\"in\" type=\"a\"/>"
+    "</signal>"
+    "<signal name=\"RegisterProperties\">"
+    "<arg name=\"prop\" direction=\"in\" type=\"a\"/>"
+    "</signal>"
+    "<signal name=\"UpdateProperty\">"
+    "<arg name=\"prop\" direction=\"in\" type=\"s\"/>"
+    "</signal>"
+    "<signal name=\"RemoveProperty\">"
+    "<arg name=\"prop\" direction=\"in\" type=\"s\"/>"
+    "</signal>"
+    "<signal name=\"ShowAux\">"
+    "<arg name=\"toshow\" direction=\"in\" type=\"b\"/>"
+    "</signal>"
+    "<signal name=\"ShowPreedit\">"
+    "<arg name=\"toshow\" direction=\"in\" type=\"b\"/>"
+    "</signal>"
+    "<signal name=\"ShowLookupTable\">"
+    "<arg name=\"toshow\" direction=\"in\" type=\"b\"/>"
+    "</signal>"
+    "<signal name=\"UpdateLookupTable\">"
+    "<arg name=\"label\" direction=\"in\" type=\"a\"/>"
+    "<arg name=\"text\" direction=\"in\" type=\"a\"/>"
+    "</signal>"
+    "<signal name=\"UpdateLookupTableCursor\">"
+    "<arg name=\"cursor\" direction=\"in\" type=\"i\"/>"
+    "</signal>"
+    "<signal name=\"UpdatePreeditCaret\">"
+    "<arg name=\"position\" direction=\"in\" type=\"i\"/>"
+    "</signal>"
+    "<signal name=\"UpdatePreeditText\">"
+    "<arg name=\"text\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"attr\" direction=\"in\" type=\"s\"/>"
+    "</signal>"
+    "<signal name=\"UpdateAux\">"
+    "<arg name=\"text\" direction=\"in\" type=\"s\"/>"
+    "<arg name=\"attr\" direction=\"in\" type=\"s\"/>"
+    "</signal>"
+    "<signal name=\"UpdateSpotLocation\">"
+    "<arg name=\"x\" direction=\"in\" type=\"i\"/>"
+    "<arg name=\"y\" direction=\"in\" type=\"i\"/>"
+    "</signal>"
+    "<signal name=\"UpdateScreen\">"
+    "<arg name=\"screen\" direction=\"in\" type=\"i\"/>"
+    "</signal>"
+    "<signal name=\"Enable\">"
+    "<arg name=\"toenable\" direction=\"in\" type=\"b\"/>"
+    "</signal>"
+    "</interface>"
+    "</node>";
 
 typedef struct _FcitxKimpanelUI {
     FcitxInstance* owner;
@@ -166,7 +166,7 @@ static void KimUpdateProperty(FcitxKimpanelUI* kimpanel, char *prop);
 static DBusHandlerResult KimpanelDBusEventHandler(DBusConnection *connection, DBusMessage *message, void *user_data);
 static DBusHandlerResult KimpanelDBusFilter(DBusConnection *connection, DBusMessage *message, void *user_data);
 static int CalKimCursorPos(FcitxKimpanelUI *kimpanel);
-static void KimpanelInputReset(void *arg);
+static void KimpanelInputIMChanged(void *arg);
 static char* Status2String(FcitxUIStatus* status);
 static char* ComplexStatus2String(FcitxUIComplexStatus* status);
 static void KimpanelRegisterAllStatus(FcitxKimpanelUI* kimpanel);
@@ -334,10 +334,10 @@ void* KimpanelCreate(FcitxInstance* instance)
         kimpanel->messageUp = FcitxMessagesNew();
         kimpanel->messageDown = FcitxMessagesNew();
 
-        FcitxIMEventHook resethk;
-        resethk.arg = kimpanel;
-        resethk.func = KimpanelInputReset;
-        FcitxInstanceRegisterResetInputHook(instance, resethk);
+        FcitxIMEventHook imchangehk;
+        imchangehk.arg = kimpanel;
+        imchangehk.func = KimpanelInputIMChanged;
+        FcitxInstanceRegisterIMChangedHook(instance, imchangehk);
 
         const char* kimpanelServiceName = "org.kde.impanel";
         DBusMessage* message = dbus_message_new_method_call(DBUS_SERVICE_DBUS, DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS, "NameHasOwner");
@@ -417,7 +417,7 @@ void KimpanelSetIMStatus(FcitxKimpanelUI* kimpanel)
     free(status);
 }
 
-void KimpanelInputReset(void* arg)
+void KimpanelInputIMChanged(void* arg)
 {
     FcitxKimpanelUI* kimpanel = (FcitxKimpanelUI*) arg;
     if (kimpanel->addon != FcitxInstanceGetCurrentUI(kimpanel->owner))
@@ -885,17 +885,18 @@ DBusHandlerResult KimpanelDBusFilter(DBusConnection* connection, DBusMessage* ms
                                   DBUS_TYPE_STRING, &newowner ,
                                   DBUS_TYPE_INVALID)) {
             /* old die and no new one */
-            if (strcmp(service, "org.kde.impanel") == 0
-                && strlen(oldowner) > 0
-                && strlen(newowner) == 0)
-                FcitxUISwitchToFallback(instance);
-            /*
-             * since if new rise, it will send PanelCreated,
-             * So don't need to re-register here
-             */
+            if (strcmp(service, "org.kde.impanel") == 0) {
+                if (strlen(oldowner) > 0 && strlen(newowner) == 0) {
+                    FcitxUISwitchToFallback(instance);
+                }
+                /*
+                 * since if new rise, it will send PanelCreated,
+                 * So don't need to re-register here
+                 */
+                return DBUS_HANDLER_RESULT_HANDLED;
+            }
         }
         dbus_error_free(&error);
-        return DBUS_HANDLER_RESULT_HANDLED;
     }
 
     return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
diff --git a/tools/gui/quickphrase-editor/CMakeLists.txt b/tools/gui/quickphrase-editor/CMakeLists.txt
index 9ef7e86..3fff180 100644
--- a/tools/gui/quickphrase-editor/CMakeLists.txt
+++ b/tools/gui/quickphrase-editor/CMakeLists.txt
@@ -16,7 +16,7 @@ fcitx_translate_add_sources(
   ${QUICKPHRASE_EDITOR_HDRS}
   ${QUICKPHRASE_EDITOR_SRCS})
 
-if(NOT ENABLE_QT)
+if(NOT (ENABLE_QT AND ENABLE_QT_GUI))
   return()
 endif()
 
diff --git a/tools/gui/quickphrase-editor/editordialog.ui b/tools/gui/quickphrase-editor/editordialog.ui
index dca3359..5a2e0cb 100644
--- a/tools/gui/quickphrase-editor/editordialog.ui
+++ b/tools/gui/quickphrase-editor/editordialog.ui
@@ -13,26 +13,26 @@
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <layout class="QFormLayout" name="formLayout">
-     <item row="1" column="1">
-      <widget class="QLineEdit" name="valueLineEdit"/>
+     <item row="0" column="1">
+      <widget class="QLineEdit" name="keyLineEdit"/>
      </item>
-     <item row="1" column="0">
+     <item row="0" column="0">
       <widget class="QLabel" name="keyLabel">
        <property name="text">
         <string notr="true"/>
        </property>
       </widget>
      </item>
-     <item row="0" column="0">
+     <item row="1" column="1">
+      <widget class="QLineEdit" name="valueLineEdit"/>
+     </item>
+     <item row="1" column="0">
       <widget class="QLabel" name="valueLabel">
        <property name="text">
         <string notr="true"/>
        </property>
       </widget>
      </item>
-     <item row="0" column="1">
-      <widget class="QLineEdit" name="keyLineEdit"/>
-     </item>
     </layout>
    </item>
    <item>
@@ -49,8 +49,6 @@
  </widget>
  <tabstops>
   <tabstop>keyLineEdit</tabstop>
-  <tabstop>valueLineEdit</tabstop>
-  <tabstop>buttonBox</tabstop>
  </tabstops>
  <resources/>
  <connections>
diff --git a/tools/gui/wrapper/CMakeLists.txt b/tools/gui/wrapper/CMakeLists.txt
index ab1fbaa..27ccb74 100644
--- a/tools/gui/wrapper/CMakeLists.txt
+++ b/tools/gui/wrapper/CMakeLists.txt
@@ -11,7 +11,7 @@ fcitx_translate_add_sources(
   ${QT_WRAPPER_SRCS}
   ${QT_WRAPPER_HDRS})
 
-if(NOT ENABLE_QT)
+if(NOT (ENABLE_QT AND ENABLE_QT_GUI))
   return()
 endif()
 
@@ -36,4 +36,4 @@ target_link_libraries(fcitx-qt-gui-wrapper
   fcitx-qt
   )
 
-install(TARGETS fcitx-qt-gui-wrapper DESTINATION ${bindir})
+install(TARGETS fcitx-qt-gui-wrapper DESTINATION ${addondir}/libexec)
-- 
